{"ast":null,"code":"/*! @name mpd-parser @version 1.0.1 @license Apache-2.0 */\nimport resolveUrl from '@videojs/vhs-utils/es/resolve-url';\nimport window from 'global/window';\nimport { forEachMediaGroup } from '@videojs/vhs-utils/es/media-groups';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/es/decode-b64-to-uint8-array';\nimport { DOMParser } from '@xmldom/xmldom';\nvar version = \"1.0.1\";\nconst isObject = obj => {\n  return !!obj && typeof obj === 'object';\n};\nconst merge = function () {\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n  return objects.reduce((result, source) => {\n    if (typeof source !== 'object') {\n      return result;\n    }\n    Object.keys(source).forEach(key => {\n      if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n        result[key] = result[key].concat(source[key]);\n      } else if (isObject(result[key]) && isObject(source[key])) {\n        result[key] = merge(result[key], source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  }, {});\n};\nconst values = o => Object.keys(o).map(k => o[k]);\nconst range = (start, end) => {\n  const result = [];\n  for (let i = start; i < end; i++) {\n    result.push(i);\n  }\n  return result;\n};\nconst flatten = lists => lists.reduce((x, y) => x.concat(y), []);\nconst from = list => {\n  if (!list.length) {\n    return [];\n  }\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    result.push(list[i]);\n  }\n  return result;\n};\nconst findIndexes = (l, key) => l.reduce((a, e, i) => {\n  if (e[key]) {\n    a.push(i);\n  }\n  return a;\n}, []);\n/**\n * Returns a union of the included lists provided each element can be identified by a key.\n *\n * @param {Array} list - list of lists to get the union of\n * @param {Function} keyFunction - the function to use as a key for each element\n *\n * @return {Array} the union of the arrays\n */\n\nconst union = (lists, keyFunction) => {\n  return values(lists.reduce((acc, list) => {\n    list.forEach(el => {\n      acc[keyFunction(el)] = el;\n    });\n    return acc;\n  }, {}));\n};\nvar errors = {\n  INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n  DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n  DASH_INVALID_XML: 'DASH_INVALID_XML',\n  NO_BASE_URL: 'NO_BASE_URL',\n  MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n  SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n  UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n};\n\n/**\n * @typedef {Object} SingleUri\n * @property {string} uri - relative location of segment\n * @property {string} resolvedUri - resolved location of segment\n * @property {Object} byterange - Object containing information on how to make byte range\n *   requests following byte-range-spec per RFC2616.\n * @property {String} byterange.length - length of range request\n * @property {String} byterange.offset - byte offset of range request\n *\n * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n */\n\n/**\n * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n * that conforms to how m3u8-parser is structured\n *\n * @see https://github.com/videojs/m3u8-parser\n *\n * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n * @param {string} source - source url for segment\n * @param {string} range - optional range used for range calls,\n *   follows  RFC 2616, Clause 14.35.1\n * @return {SingleUri} full segment information transformed into a format similar\n *   to m3u8-parser\n */\n\nconst urlTypeToSegment = _ref => {\n  let {\n    baseUrl = '',\n    source = '',\n    range = '',\n    indexRange = ''\n  } = _ref;\n  const segment = {\n    uri: source,\n    resolvedUri: resolveUrl(baseUrl || '', source)\n  };\n  if (range || indexRange) {\n    const rangeStr = range ? range : indexRange;\n    const ranges = rangeStr.split('-'); // default to parsing this as a BigInt if possible\n\n    let startRange = window.BigInt ? window.BigInt(ranges[0]) : parseInt(ranges[0], 10);\n    let endRange = window.BigInt ? window.BigInt(ranges[1]) : parseInt(ranges[1], 10); // convert back to a number if less than MAX_SAFE_INTEGER\n\n    if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === 'bigint') {\n      startRange = Number(startRange);\n    }\n    if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === 'bigint') {\n      endRange = Number(endRange);\n    }\n    let length;\n    if (typeof endRange === 'bigint' || typeof startRange === 'bigint') {\n      length = window.BigInt(endRange) - window.BigInt(startRange) + window.BigInt(1);\n    } else {\n      length = endRange - startRange + 1;\n    }\n    if (typeof length === 'bigint' && length < Number.MAX_SAFE_INTEGER) {\n      length = Number(length);\n    } // byterange should be inclusive according to\n    // RFC 2616, Clause 14.35.1\n\n    segment.byterange = {\n      length,\n      offset: startRange\n    };\n  }\n  return segment;\n};\nconst byteRangeToString = byterange => {\n  // `endRange` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  let endRange;\n  if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n    endRange = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);\n  } else {\n    endRange = byterange.offset + byterange.length - 1;\n  }\n  return `${byterange.offset}-${endRange}`;\n};\n\n/**\n * parse the end number attribue that can be a string\n * number, or undefined.\n *\n * @param {string|number|undefined} endNumber\n *        The end number attribute.\n *\n * @return {number|null}\n *          The result of parsing the end number.\n */\n\nconst parseEndNumber = endNumber => {\n  if (endNumber && typeof endNumber !== 'number') {\n    endNumber = parseInt(endNumber, 10);\n  }\n  if (isNaN(endNumber)) {\n    return null;\n  }\n  return endNumber;\n};\n/**\n * Functions for calculating the range of available segments in static and dynamic\n * manifests.\n */\n\nconst segmentRange = {\n  /**\n   * Returns the entire range of available segments for a static MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  static(attributes) {\n    const {\n      duration,\n      timescale = 1,\n      sourceDuration,\n      periodDuration\n    } = attributes;\n    const endNumber = parseEndNumber(attributes.endNumber);\n    const segmentDuration = duration / timescale;\n    if (typeof endNumber === 'number') {\n      return {\n        start: 0,\n        end: endNumber\n      };\n    }\n    if (typeof periodDuration === 'number') {\n      return {\n        start: 0,\n        end: periodDuration / segmentDuration\n      };\n    }\n    return {\n      start: 0,\n      end: sourceDuration / segmentDuration\n    };\n  },\n  /**\n   * Returns the current live window range of available segments for a dynamic MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  dynamic(attributes) {\n    const {\n      NOW,\n      clientOffset,\n      availabilityStartTime,\n      timescale = 1,\n      duration,\n      periodStart = 0,\n      minimumUpdatePeriod = 0,\n      timeShiftBufferDepth = Infinity\n    } = attributes;\n    const endNumber = parseEndNumber(attributes.endNumber); // clientOffset is passed in at the top level of mpd-parser and is an offset calculated\n    // after retrieving UTC server time.\n\n    const now = (NOW + clientOffset) / 1000; // WC stands for Wall Clock.\n    // Convert the period start time to EPOCH.\n\n    const periodStartWC = availabilityStartTime + periodStart; // Period end in EPOCH is manifest's retrieval time + time until next update.\n\n    const periodEndWC = now + minimumUpdatePeriod;\n    const periodDuration = periodEndWC - periodStartWC;\n    const segmentCount = Math.ceil(periodDuration * timescale / duration);\n    const availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n    const availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n    return {\n      start: Math.max(0, availableStart),\n      end: typeof endNumber === 'number' ? endNumber : Math.min(segmentCount, availableEnd)\n    };\n  }\n};\n/**\n * Maps a range of numbers to objects with information needed to build the corresponding\n * segment list\n *\n * @name toSegmentsCallback\n * @function\n * @param {number} number\n *        Number of the segment\n * @param {number} index\n *        Index of the number in the range list\n * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n *         Object with segment timing and duration info\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping a range of numbers to\n * information needed to build the segment list.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {toSegmentsCallback}\n *         Callback map function\n */\n\nconst toSegments = attributes => number => {\n  const {\n    duration,\n    timescale = 1,\n    periodStart,\n    startNumber = 1\n  } = attributes;\n  return {\n    number: startNumber + number,\n    duration: duration / timescale,\n    timeline: periodStart,\n    time: number * duration\n  };\n};\n/**\n * Returns a list of objects containing segment timing and duration info used for\n * building the list of segments. This uses the @duration attribute specified\n * in the MPD manifest to derive the range of segments.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nconst parseByDuration = attributes => {\n  const {\n    type,\n    duration,\n    timescale = 1,\n    periodDuration,\n    sourceDuration\n  } = attributes;\n  const {\n    start,\n    end\n  } = segmentRange[type](attributes);\n  const segments = range(start, end).map(toSegments(attributes));\n  if (type === 'static') {\n    const index = segments.length - 1; // section is either a period or the full source\n\n    const sectionDuration = typeof periodDuration === 'number' ? periodDuration : sourceDuration; // final segment may be less than full segment duration\n\n    segments[index].duration = sectionDuration - duration / timescale * index;\n  }\n  return segments;\n};\n\n/**\n * Translates SegmentBase into a set of segments.\n * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @return {Object.<Array>} list of segments\n */\n\nconst segmentsFromBase = attributes => {\n  const {\n    baseUrl,\n    initialization = {},\n    sourceDuration,\n    indexRange = '',\n    periodStart,\n    presentationTime,\n    number = 0,\n    duration\n  } = attributes; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n  if (!baseUrl) {\n    throw new Error(errors.NO_BASE_URL);\n  }\n  const initSegment = urlTypeToSegment({\n    baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  const segment = urlTypeToSegment({\n    baseUrl,\n    source: baseUrl,\n    indexRange\n  });\n  segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n  // (since SegmentBase is only for one total segment)\n\n  if (duration) {\n    const segmentTimeInfo = parseByDuration(attributes);\n    if (segmentTimeInfo.length) {\n      segment.duration = segmentTimeInfo[0].duration;\n      segment.timeline = segmentTimeInfo[0].timeline;\n    }\n  } else if (sourceDuration) {\n    segment.duration = sourceDuration;\n    segment.timeline = periodStart;\n  } // If presentation time is provided, these segments are being generated by SIDX\n  // references, and should use the time provided. For the general case of SegmentBase,\n  // there should only be one segment in the period, so its presentation time is the same\n  // as its period start.\n\n  segment.presentationTime = presentationTime || periodStart;\n  segment.number = number;\n  return [segment];\n};\n/**\n * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n * according to the sidx information given.\n *\n * playlist.sidx has metadadata about the sidx where-as the sidx param\n * is the parsed sidx box itself.\n *\n * @param {Object} playlist the playlist to update the sidx information for\n * @param {Object} sidx the parsed sidx box\n * @return {Object} the playlist object with the updated sidx information\n */\n\nconst addSidxSegmentsToPlaylist$1 = (playlist, sidx, baseUrl) => {\n  // Retain init segment information\n  const initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial main manifest parsing\n\n  const sourceDuration = playlist.sidx.duration; // Retain source timeline\n\n  const timeline = playlist.timeline || 0;\n  const sidxByteRange = playlist.sidx.byterange;\n  const sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n\n  const timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n\n  const mediaReferences = sidx.references.filter(r => r.referenceType !== 1);\n  const segments = [];\n  const type = playlist.endList ? 'static' : 'dynamic';\n  const periodStart = playlist.sidx.timeline;\n  let presentationTime = periodStart;\n  let number = playlist.mediaSequence || 0; // firstOffset is the offset from the end of the sidx box\n\n  let startIndex; // eslint-disable-next-line\n\n  if (typeof sidx.firstOffset === 'bigint') {\n    startIndex = window.BigInt(sidxEnd) + sidx.firstOffset;\n  } else {\n    startIndex = sidxEnd + sidx.firstOffset;\n  }\n  for (let i = 0; i < mediaReferences.length; i++) {\n    const reference = sidx.references[i]; // size of the referenced (sub)segment\n\n    const size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n    // this will be converted to seconds when generating segments\n\n    const duration = reference.subsegmentDuration; // should be an inclusive range\n\n    let endIndex; // eslint-disable-next-line\n\n    if (typeof startIndex === 'bigint') {\n      endIndex = startIndex + window.BigInt(size) - window.BigInt(1);\n    } else {\n      endIndex = startIndex + size - 1;\n    }\n    const indexRange = `${startIndex}-${endIndex}`;\n    const attributes = {\n      baseUrl,\n      timescale,\n      timeline,\n      periodStart,\n      presentationTime,\n      number,\n      duration,\n      sourceDuration,\n      indexRange,\n      type\n    };\n    const segment = segmentsFromBase(attributes)[0];\n    if (initSegment) {\n      segment.map = initSegment;\n    }\n    segments.push(segment);\n    if (typeof startIndex === 'bigint') {\n      startIndex += window.BigInt(size);\n    } else {\n      startIndex += size;\n    }\n    presentationTime += duration / timescale;\n    number++;\n  }\n  playlist.segments = segments;\n  return playlist;\n};\nconst SUPPORTED_MEDIA_TYPES = ['AUDIO', 'SUBTITLES']; // allow one 60fps frame as leniency (arbitrarily chosen)\n\nconst TIME_FUDGE = 1 / 60;\n/**\n * Given a list of timelineStarts, combines, dedupes, and sorts them.\n *\n * @param {TimelineStart[]} timelineStarts - list of timeline starts\n *\n * @return {TimelineStart[]} the combined and deduped timeline starts\n */\n\nconst getUniqueTimelineStarts = timelineStarts => {\n  return union(timelineStarts, _ref2 => {\n    let {\n      timeline\n    } = _ref2;\n    return timeline;\n  }).sort((a, b) => a.timeline > b.timeline ? 1 : -1);\n};\n/**\n * Finds the playlist with the matching NAME attribute.\n *\n * @param {Array} playlists - playlists to search through\n * @param {string} name - the NAME attribute to search for\n *\n * @return {Object|null} the matching playlist object, or null\n */\n\nconst findPlaylistWithName = (playlists, name) => {\n  for (let i = 0; i < playlists.length; i++) {\n    if (playlists[i].attributes.NAME === name) {\n      return playlists[i];\n    }\n  }\n  return null;\n};\n/**\n * Gets a flattened array of media group playlists.\n *\n * @param {Object} manifest - the main manifest object\n *\n * @return {Array} the media group playlists\n */\n\nconst getMediaGroupPlaylists = manifest => {\n  let mediaGroupPlaylists = [];\n  forEachMediaGroup(manifest, SUPPORTED_MEDIA_TYPES, (properties, type, group, label) => {\n    mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);\n  });\n  return mediaGroupPlaylists;\n};\n/**\n * Updates the playlist's media sequence numbers.\n *\n * @param {Object} config - options object\n * @param {Object} config.playlist - the playlist to update\n * @param {number} config.mediaSequence - the mediaSequence number to start with\n */\n\nconst updateMediaSequenceForPlaylist = _ref3 => {\n  let {\n    playlist,\n    mediaSequence\n  } = _ref3;\n  playlist.mediaSequence = mediaSequence;\n  playlist.segments.forEach((segment, index) => {\n    segment.number = playlist.mediaSequence + index;\n  });\n};\n/**\n * Updates the media and discontinuity sequence numbers of newPlaylists given oldPlaylists\n * and a complete list of timeline starts.\n *\n * If no matching playlist is found, only the discontinuity sequence number of the playlist\n * will be updated.\n *\n * Since early available timelines are not supported, at least one segment must be present.\n *\n * @param {Object} config - options object\n * @param {Object[]} oldPlaylists - the old playlists to use as a reference\n * @param {Object[]} newPlaylists - the new playlists to update\n * @param {Object} timelineStarts - all timelineStarts seen in the stream to this point\n */\n\nconst updateSequenceNumbers = _ref4 => {\n  let {\n    oldPlaylists,\n    newPlaylists,\n    timelineStarts\n  } = _ref4;\n  newPlaylists.forEach(playlist => {\n    playlist.discontinuitySequence = timelineStarts.findIndex(function (_ref5) {\n      let {\n        timeline\n      } = _ref5;\n      return timeline === playlist.timeline;\n    }); // Playlists NAMEs come from DASH Representation IDs, which are mandatory\n    // (see ISO_23009-1-2012 5.3.5.2).\n    //\n    // If the same Representation existed in a prior Period, it will retain the same NAME.\n\n    const oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);\n    if (!oldPlaylist) {\n      // Since this is a new playlist, the media sequence values can start from 0 without\n      // consequence.\n      return;\n    } // TODO better support for live SIDX\n    //\n    // As of this writing, mpd-parser does not support multiperiod SIDX (in live or VOD).\n    // This is evident by a playlist only having a single SIDX reference. In a multiperiod\n    // playlist there would need to be multiple SIDX references. In addition, live SIDX is\n    // not supported when the SIDX properties change on refreshes.\n    //\n    // In the future, if support needs to be added, the merging logic here can be called\n    // after SIDX references are resolved. For now, exit early to prevent exceptions being\n    // thrown due to undefined references.\n\n    if (playlist.sidx) {\n      return;\n    } // Since we don't yet support early available timelines, we don't need to support\n    // playlists with no segments.\n\n    const firstNewSegment = playlist.segments[0];\n    const oldMatchingSegmentIndex = oldPlaylist.segments.findIndex(function (oldSegment) {\n      return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;\n    }); // No matching segment from the old playlist means the entire playlist was refreshed.\n    // In this case the media sequence should account for this update, and the new segments\n    // should be marked as discontinuous from the prior content, since the last prior\n    // timeline was removed.\n\n    if (oldMatchingSegmentIndex === -1) {\n      updateMediaSequenceForPlaylist({\n        playlist,\n        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length\n      });\n      playlist.segments[0].discontinuity = true;\n      playlist.discontinuityStarts.unshift(0); // No matching segment does not necessarily mean there's missing content.\n      //\n      // If the new playlist's timeline is the same as the last seen segment's timeline,\n      // then a discontinuity can be added to identify that there's potentially missing\n      // content. If there's no missing content, the discontinuity should still be rather\n      // harmless. It's possible that if segment durations are accurate enough, that the\n      // existence of a gap can be determined using the presentation times and durations,\n      // but if the segment timing info is off, it may introduce more problems than simply\n      // adding the discontinuity.\n      //\n      // If the new playlist's timeline is different from the last seen segment's timeline,\n      // then a discontinuity can be added to identify that this is the first seen segment\n      // of a new timeline. However, the logic at the start of this function that\n      // determined the disconinuity sequence by timeline index is now off by one (the\n      // discontinuity of the newest timeline hasn't yet fallen off the manifest...since\n      // we added it), so the disconinuity sequence must be decremented.\n      //\n      // A period may also have a duration of zero, so the case of no segments is handled\n      // here even though we don't yet support early available periods.\n\n      if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {\n        playlist.discontinuitySequence--;\n      }\n      return;\n    } // If the first segment matched with a prior segment on a discontinuity (it's matching\n    // on the first segment of a period), then the discontinuitySequence shouldn't be the\n    // timeline's matching one, but instead should be the one prior, and the first segment\n    // of the new manifest should be marked with a discontinuity.\n    //\n    // The reason for this special case is that discontinuity sequence shows how many\n    // discontinuities have fallen off of the playlist, and discontinuities are marked on\n    // the first segment of a new \"timeline.\" Because of this, while DASH will retain that\n    // Period while the \"timeline\" exists, HLS keeps track of it via the discontinuity\n    // sequence, and that first segment is an indicator, but can be removed before that\n    // timeline is gone.\n\n    const oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];\n    if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {\n      firstNewSegment.discontinuity = true;\n      playlist.discontinuityStarts.unshift(0);\n      playlist.discontinuitySequence--;\n    }\n    updateMediaSequenceForPlaylist({\n      playlist,\n      mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number\n    });\n  });\n};\n/**\n * Given an old parsed manifest object and a new parsed manifest object, updates the\n * sequence and timing values within the new manifest to ensure that it lines up with the\n * old.\n *\n * @param {Array} oldManifest - the old main manifest object\n * @param {Array} newManifest - the new main manifest object\n *\n * @return {Object} the updated new manifest object\n */\n\nconst positionManifestOnTimeline = _ref6 => {\n  let {\n    oldManifest,\n    newManifest\n  } = _ref6;\n  // Starting from v4.1.2 of the IOP, section 4.4.3.3 states:\n  //\n  // \"MPD@availabilityStartTime and Period@start shall not be changed over MPD updates.\"\n  //\n  // This was added from https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/160\n  //\n  // Because of this change, and the difficulty of supporting periods with changing start\n  // times, periods with changing start times are not supported. This makes the logic much\n  // simpler, since periods with the same start time can be considerred the same period\n  // across refreshes.\n  //\n  // To give an example as to the difficulty of handling periods where the start time may\n  // change, if a single period manifest is refreshed with another manifest with a single\n  // period, and both the start and end times are increased, then the only way to determine\n  // if it's a new period or an old one that has changed is to look through the segments of\n  // each playlist and determine the presentation time bounds to find a match. In addition,\n  // if the period start changed to exceed the old period end, then there would be no\n  // match, and it would not be possible to determine whether the refreshed period is a new\n  // one or the old one.\n  const oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));\n  const newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest)); // Save all seen timelineStarts to the new manifest. Although this potentially means that\n  // there's a \"memory leak\" in that it will never stop growing, in reality, only a couple\n  // of properties are saved for each seen Period. Even long running live streams won't\n  // generate too many Periods, unless the stream is watched for decades. In the future,\n  // this can be optimized by mapping to discontinuity sequence numbers for each timeline,\n  // but it may not become an issue, and the additional info can be useful for debugging.\n\n  newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);\n  updateSequenceNumbers({\n    oldPlaylists,\n    newPlaylists,\n    timelineStarts: newManifest.timelineStarts\n  });\n  return newManifest;\n};\nconst generateSidxKey = sidx => sidx && sidx.uri + '-' + byteRangeToString(sidx.byterange);\nconst mergeDiscontiguousPlaylists = playlists => {\n  const mergedPlaylists = values(playlists.reduce((acc, playlist) => {\n    // assuming playlist IDs are the same across periods\n    // TODO: handle multiperiod where representation sets are not the same\n    // across periods\n    const name = playlist.attributes.id + (playlist.attributes.lang || '');\n    if (!acc[name]) {\n      // First Period\n      acc[name] = playlist;\n      acc[name].attributes.timelineStarts = [];\n    } else {\n      // Subsequent Periods\n      if (playlist.segments) {\n        // first segment of subsequent periods signal a discontinuity\n        if (playlist.segments[0]) {\n          playlist.segments[0].discontinuity = true;\n        }\n        acc[name].segments.push(...playlist.segments);\n      } // bubble up contentProtection, this assumes all DRM content\n      // has the same contentProtection\n\n      if (playlist.attributes.contentProtection) {\n        acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n      }\n    }\n    acc[name].attributes.timelineStarts.push({\n      // Although they represent the same number, it's important to have both to make it\n      // compatible with HLS potentially having a similar attribute.\n      start: playlist.attributes.periodStart,\n      timeline: playlist.attributes.periodStart\n    });\n    return acc;\n  }, {}));\n  return mergedPlaylists.map(playlist => {\n    playlist.discontinuityStarts = findIndexes(playlist.segments || [], 'discontinuity');\n    return playlist;\n  });\n};\nconst addSidxSegmentsToPlaylist = (playlist, sidxMapping) => {\n  const sidxKey = generateSidxKey(playlist.sidx);\n  const sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n  if (sidxMatch) {\n    addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);\n  }\n  return playlist;\n};\nconst addSidxSegmentsToPlaylists = function (playlists) {\n  let sidxMapping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!Object.keys(sidxMapping).length) {\n    return playlists;\n  }\n  for (const i in playlists) {\n    playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);\n  }\n  return playlists;\n};\nconst formatAudioPlaylist = (_ref7, isAudioOnly) => {\n  let {\n    attributes,\n    segments,\n    sidx,\n    mediaSequence,\n    discontinuitySequence,\n    discontinuityStarts\n  } = _ref7;\n  const playlist = {\n    attributes: {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth,\n      CODECS: attributes.codecs,\n      ['PROGRAM-ID']: 1\n    },\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    discontinuitySequence,\n    discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    mediaSequence,\n    segments\n  };\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n  if (isAudioOnly) {\n    playlist.attributes.AUDIO = 'audio';\n    playlist.attributes.SUBTITLES = 'subs';\n  }\n  return playlist;\n};\nconst formatVttPlaylist = _ref8 => {\n  let {\n    attributes,\n    segments,\n    mediaSequence,\n    discontinuityStarts,\n    discontinuitySequence\n  } = _ref8;\n  if (typeof segments === 'undefined') {\n    // vtt tracks may use single file in BaseURL\n    segments = [{\n      uri: attributes.baseUrl,\n      timeline: attributes.periodStart,\n      resolvedUri: attributes.baseUrl || '',\n      duration: attributes.sourceDuration,\n      number: 0\n    }]; // targetDuration should be the same duration as the only segment\n\n    attributes.duration = attributes.sourceDuration;\n  }\n  const m3u8Attributes = {\n    NAME: attributes.id,\n    BANDWIDTH: attributes.bandwidth,\n    ['PROGRAM-ID']: 1\n  };\n  if (attributes.codecs) {\n    m3u8Attributes.CODECS = attributes.codecs;\n  }\n  return {\n    attributes: m3u8Attributes,\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    timelineStarts: attributes.timelineStarts,\n    discontinuityStarts,\n    discontinuitySequence,\n    mediaSequence,\n    segments\n  };\n};\nconst organizeAudioPlaylists = function (playlists) {\n  let sidxMapping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let isAudioOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let mainPlaylist;\n  const formattedPlaylists = playlists.reduce((a, playlist) => {\n    const role = playlist.attributes.role && playlist.attributes.role.value || '';\n    const language = playlist.attributes.lang || '';\n    let label = playlist.attributes.label || 'main';\n    if (language && !playlist.attributes.label) {\n      const roleLabel = role ? ` (${role})` : '';\n      label = `${playlist.attributes.lang}${roleLabel}`;\n    }\n    if (!a[label]) {\n      a[label] = {\n        language,\n        autoselect: true,\n        default: role === 'main',\n        playlists: [],\n        uri: ''\n      };\n    }\n    const formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);\n    a[label].playlists.push(formatted);\n    if (typeof mainPlaylist === 'undefined' && role === 'main') {\n      mainPlaylist = playlist;\n      mainPlaylist.default = true;\n    }\n    return a;\n  }, {}); // if no playlists have role \"main\", mark the first as main\n\n  if (!mainPlaylist) {\n    const firstLabel = Object.keys(formattedPlaylists)[0];\n    formattedPlaylists[firstLabel].default = true;\n  }\n  return formattedPlaylists;\n};\nconst organizeVttPlaylists = function (playlists) {\n  let sidxMapping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return playlists.reduce((a, playlist) => {\n    const label = playlist.attributes.lang || 'text';\n    if (!a[label]) {\n      a[label] = {\n        language: label,\n        default: false,\n        autoselect: false,\n        playlists: [],\n        uri: ''\n      };\n    }\n    a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));\n    return a;\n  }, {});\n};\nconst organizeCaptionServices = captionServices => captionServices.reduce((svcObj, svc) => {\n  if (!svc) {\n    return svcObj;\n  }\n  svc.forEach(service => {\n    const {\n      channel,\n      language\n    } = service;\n    svcObj[language] = {\n      autoselect: false,\n      default: false,\n      instreamId: channel,\n      language\n    };\n    if (service.hasOwnProperty('aspectRatio')) {\n      svcObj[language].aspectRatio = service.aspectRatio;\n    }\n    if (service.hasOwnProperty('easyReader')) {\n      svcObj[language].easyReader = service.easyReader;\n    }\n    if (service.hasOwnProperty('3D')) {\n      svcObj[language]['3D'] = service['3D'];\n    }\n  });\n  return svcObj;\n}, {});\nconst formatVideoPlaylist = _ref9 => {\n  let {\n    attributes,\n    segments,\n    sidx,\n    discontinuityStarts\n  } = _ref9;\n  const playlist = {\n    attributes: {\n      NAME: attributes.id,\n      AUDIO: 'audio',\n      SUBTITLES: 'subs',\n      RESOLUTION: {\n        width: attributes.width,\n        height: attributes.height\n      },\n      CODECS: attributes.codecs,\n      BANDWIDTH: attributes.bandwidth,\n      ['PROGRAM-ID']: 1\n    },\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    segments\n  };\n  if (attributes.frameRate) {\n    playlist.attributes['FRAME-RATE'] = attributes.frameRate;\n  }\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n  return playlist;\n};\nconst videoOnly = _ref10 => {\n  let {\n    attributes\n  } = _ref10;\n  return attributes.mimeType === 'video/mp4' || attributes.mimeType === 'video/webm' || attributes.contentType === 'video';\n};\nconst audioOnly = _ref11 => {\n  let {\n    attributes\n  } = _ref11;\n  return attributes.mimeType === 'audio/mp4' || attributes.mimeType === 'audio/webm' || attributes.contentType === 'audio';\n};\nconst vttOnly = _ref12 => {\n  let {\n    attributes\n  } = _ref12;\n  return attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n};\n/**\n * Contains start and timeline properties denoting a timeline start. For DASH, these will\n * be the same number.\n *\n * @typedef {Object} TimelineStart\n * @property {number} start - the start time of the timeline\n * @property {number} timeline - the timeline number\n */\n\n/**\n * Adds appropriate media and discontinuity sequence values to the segments and playlists.\n *\n * Throughout mpd-parser, the `number` attribute is used in relation to `startNumber`, a\n * DASH specific attribute used in constructing segment URI's from templates. However, from\n * an HLS perspective, the `number` attribute on a segment would be its `mediaSequence`\n * value, which should start at the original media sequence value (or 0) and increment by 1\n * for each segment thereafter. Since DASH's `startNumber` values are independent per\n * period, it doesn't make sense to use it for `number`. Instead, assume everything starts\n * from a 0 mediaSequence value and increment from there.\n *\n * Note that VHS currently doesn't use the `number` property, but it can be helpful for\n * debugging and making sense of the manifest.\n *\n * For live playlists, to account for values increasing in manifests when periods are\n * removed on refreshes, merging logic should be used to update the numbers to their\n * appropriate values (to ensure they're sequential and increasing).\n *\n * @param {Object[]} playlists - the playlists to update\n * @param {TimelineStart[]} timelineStarts - the timeline starts for the manifest\n */\n\nconst addMediaSequenceValues = (playlists, timelineStarts) => {\n  // increment all segments sequentially\n  playlists.forEach(playlist => {\n    playlist.mediaSequence = 0;\n    playlist.discontinuitySequence = timelineStarts.findIndex(function (_ref13) {\n      let {\n        timeline\n      } = _ref13;\n      return timeline === playlist.timeline;\n    });\n    if (!playlist.segments) {\n      return;\n    }\n    playlist.segments.forEach((segment, index) => {\n      segment.number = index;\n    });\n  });\n};\n/**\n * Given a media group object, flattens all playlists within the media group into a single\n * array.\n *\n * @param {Object} mediaGroupObject - the media group object\n *\n * @return {Object[]}\n *         The media group playlists\n */\n\nconst flattenMediaGroupPlaylists = mediaGroupObject => {\n  if (!mediaGroupObject) {\n    return [];\n  }\n  return Object.keys(mediaGroupObject).reduce((acc, label) => {\n    const labelContents = mediaGroupObject[label];\n    return acc.concat(labelContents.playlists);\n  }, []);\n};\nconst toM3u8 = _ref14 => {\n  let {\n    dashPlaylists,\n    locations,\n    sidxMapping = {},\n    previousManifest\n  } = _ref14;\n  if (!dashPlaylists.length) {\n    return {};\n  } // grab all main manifest attributes\n\n  const {\n    sourceDuration: duration,\n    type,\n    suggestedPresentationDelay,\n    minimumUpdatePeriod\n  } = dashPlaylists[0].attributes;\n  const videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n  const audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n  const vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));\n  const captions = dashPlaylists.map(playlist => playlist.attributes.captionServices).filter(Boolean);\n  const manifest = {\n    allowCache: true,\n    discontinuityStarts: [],\n    segments: [],\n    endList: true,\n    mediaGroups: {\n      AUDIO: {},\n      VIDEO: {},\n      ['CLOSED-CAPTIONS']: {},\n      SUBTITLES: {}\n    },\n    uri: '',\n    duration,\n    playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)\n  };\n  if (minimumUpdatePeriod >= 0) {\n    manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;\n  }\n  if (locations) {\n    manifest.locations = locations;\n  }\n  if (type === 'dynamic') {\n    manifest.suggestedPresentationDelay = suggestedPresentationDelay;\n  }\n  const isAudioOnly = manifest.playlists.length === 0;\n  const organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;\n  const organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;\n  const formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));\n  const playlistTimelineStarts = formattedPlaylists.map(_ref15 => {\n    let {\n      timelineStarts\n    } = _ref15;\n    return timelineStarts;\n  });\n  manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);\n  addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);\n  if (organizedAudioGroup) {\n    manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;\n  }\n  if (organizedVttGroup) {\n    manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;\n  }\n  if (captions.length) {\n    manifest.mediaGroups['CLOSED-CAPTIONS'].cc = organizeCaptionServices(captions);\n  }\n  if (previousManifest) {\n    return positionManifestOnTimeline({\n      oldManifest: previousManifest,\n      newManifest: manifest\n    });\n  }\n  return manifest;\n};\n\n/**\n * Calculates the R (repetition) value for a live stream (for the final segment\n * in a manifest where the r value is negative 1)\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {number} time\n *        current time (typically the total time up until the final segment)\n * @param {number} duration\n *        duration property for the given <S />\n *\n * @return {number}\n *        R value to reach the end of the given period\n */\nconst getLiveRValue = (attributes, time, duration) => {\n  const {\n    NOW,\n    clientOffset,\n    availabilityStartTime,\n    timescale = 1,\n    periodStart = 0,\n    minimumUpdatePeriod = 0\n  } = attributes;\n  const now = (NOW + clientOffset) / 1000;\n  const periodStartWC = availabilityStartTime + periodStart;\n  const periodEndWC = now + minimumUpdatePeriod;\n  const periodDuration = periodEndWC - periodStartWC;\n  return Math.ceil((periodDuration * timescale - time) / duration);\n};\n/**\n * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n * timing and duration\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nconst parseByTimeline = (attributes, segmentTimeline) => {\n  const {\n    type,\n    minimumUpdatePeriod = 0,\n    media = '',\n    sourceDuration,\n    timescale = 1,\n    startNumber = 1,\n    periodStart: timeline\n  } = attributes;\n  const segments = [];\n  let time = -1;\n  for (let sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n    const S = segmentTimeline[sIndex];\n    const duration = S.d;\n    const repeat = S.r || 0;\n    const segmentTime = S.t || 0;\n    if (time < 0) {\n      // first segment\n      time = segmentTime;\n    }\n    if (segmentTime && segmentTime > time) {\n      // discontinuity\n      // TODO: How to handle this type of discontinuity\n      // timeline++ here would treat it like HLS discontuity and content would\n      // get appended without gap\n      // E.G.\n      //  <S t=\"0\" d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S t=\"5\" d=\"1\" />\n      // would have $Time$ values of [0, 1, 2, 5]\n      // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n      // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n      // does the value of sourceDuration consider this when calculating arbitrary\n      // negative @r repeat value?\n      // E.G. Same elements as above with this added at the end\n      //  <S d=\"1\" r=\"-1\" />\n      //  with a sourceDuration of 10\n      // Would the 2 gaps be included in the time duration calculations resulting in\n      // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n      // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n      time = segmentTime;\n    }\n    let count;\n    if (repeat < 0) {\n      const nextS = sIndex + 1;\n      if (nextS === segmentTimeline.length) {\n        // last segment\n        if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n          count = getLiveRValue(attributes, time, duration);\n        } else {\n          // TODO: This may be incorrect depending on conclusion of TODO above\n          count = (sourceDuration * timescale - time) / duration;\n        }\n      } else {\n        count = (segmentTimeline[nextS].t - time) / duration;\n      }\n    } else {\n      count = repeat + 1;\n    }\n    const end = startNumber + segments.length + count;\n    let number = startNumber + segments.length;\n    while (number < end) {\n      segments.push({\n        number,\n        duration: duration / timescale,\n        time,\n        timeline\n      });\n      time += duration;\n      number++;\n    }\n  }\n  return segments;\n};\nconst identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n/**\n * Replaces template identifiers with corresponding values. To be used as the callback\n * for String.prototype.replace\n *\n * @name replaceCallback\n * @function\n * @param {string} match\n *        Entire match of identifier\n * @param {string} identifier\n *        Name of matched identifier\n * @param {string} format\n *        Format tag string. Its presence indicates that padding is expected\n * @param {string} width\n *        Desired length of the replaced value. Values less than this width shall be left\n *        zero padded\n * @return {string}\n *         Replacement for the matched identifier\n */\n\n/**\n * Returns a function to be used as a callback for String.prototype.replace to replace\n * template identifiers\n *\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {replaceCallback}\n *         Callback to be used with String.prototype.replace to replace identifiers\n */\n\nconst identifierReplacement = values => (match, identifier, format, width) => {\n  if (match === '$$') {\n    // escape sequence\n    return '$';\n  }\n  if (typeof values[identifier] === 'undefined') {\n    return match;\n  }\n  const value = '' + values[identifier];\n  if (identifier === 'RepresentationID') {\n    // Format tag shall not be present with RepresentationID\n    return value;\n  }\n  if (!format) {\n    width = 1;\n  } else {\n    width = parseInt(width, 10);\n  }\n  if (value.length >= width) {\n    return value;\n  }\n  return `${new Array(width - value.length + 1).join('0')}${value}`;\n};\n/**\n * Constructs a segment url from a template string\n *\n * @param {string} url\n *        Template string to construct url from\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {string}\n *         Segment url with identifiers replaced\n */\n\nconst constructTemplateUrl = (url, values) => url.replace(identifierPattern, identifierReplacement(values));\n/**\n * Generates a list of objects containing timing and duration information about each\n * segment needed to generate segment uris and the complete segment object\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nconst parseTemplateInfo = (attributes, segmentTimeline) => {\n  if (!attributes.duration && !segmentTimeline) {\n    // if neither @duration or SegmentTimeline are present, then there shall be exactly\n    // one media segment\n    return [{\n      number: attributes.startNumber || 1,\n      duration: attributes.sourceDuration,\n      time: 0,\n      timeline: attributes.periodStart\n    }];\n  }\n  if (attributes.duration) {\n    return parseByDuration(attributes);\n  }\n  return parseByTimeline(attributes, segmentTimeline);\n};\n/**\n * Generates a list of segments using information provided by the SegmentTemplate element\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object[]}\n *         List of segment objects\n */\n\nconst segmentsFromTemplate = (attributes, segmentTimeline) => {\n  const templateValues = {\n    RepresentationID: attributes.id,\n    Bandwidth: attributes.bandwidth || 0\n  };\n  const {\n    initialization = {\n      sourceURL: '',\n      range: ''\n    }\n  } = attributes;\n  const mapSegment = urlTypeToSegment({\n    baseUrl: attributes.baseUrl,\n    source: constructTemplateUrl(initialization.sourceURL, templateValues),\n    range: initialization.range\n  });\n  const segments = parseTemplateInfo(attributes, segmentTimeline);\n  return segments.map(segment => {\n    templateValues.Number = segment.number;\n    templateValues.Time = segment.time;\n    const uri = constructTemplateUrl(attributes.media || '', templateValues); // See DASH spec section 5.3.9.2.2\n    // - if timescale isn't present on any level, default to 1.\n\n    const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n    const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n    const presentationTime =\n    // Even if the @t attribute is not specified for the segment, segment.time is\n    // calculated in mpd-parser prior to this, so it's assumed to be available.\n    attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;\n    const map = {\n      uri,\n      timeline: segment.timeline,\n      duration: segment.duration,\n      resolvedUri: resolveUrl(attributes.baseUrl || '', uri),\n      map: mapSegment,\n      number: segment.number,\n      presentationTime\n    };\n    return map;\n  });\n};\n\n/**\n * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n * to an object that matches the output of a segment in videojs/mpd-parser\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object} segmentUrl\n *   <SegmentURL> node to translate into a segment object\n * @return {Object} translated segment object\n */\n\nconst SegmentURLToSegmentObject = (attributes, segmentUrl) => {\n  const {\n    baseUrl,\n    initialization = {}\n  } = attributes;\n  const initSegment = urlTypeToSegment({\n    baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  const segment = urlTypeToSegment({\n    baseUrl,\n    source: segmentUrl.media,\n    range: segmentUrl.mediaRange\n  });\n  segment.map = initSegment;\n  return segment;\n};\n/**\n * Generates a list of segments using information provided by the SegmentList element\n * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object.<Array>} list of segments\n */\n\nconst segmentsFromList = (attributes, segmentTimeline) => {\n  const {\n    duration,\n    segmentUrls = [],\n    periodStart\n  } = attributes; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n  // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n  if (!duration && !segmentTimeline || duration && segmentTimeline) {\n    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n  }\n  const segmentUrlMap = segmentUrls.map(segmentUrlObject => SegmentURLToSegmentObject(attributes, segmentUrlObject));\n  let segmentTimeInfo;\n  if (duration) {\n    segmentTimeInfo = parseByDuration(attributes);\n  }\n  if (segmentTimeline) {\n    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n  }\n  const segments = segmentTimeInfo.map((segmentTime, index) => {\n    if (segmentUrlMap[index]) {\n      const segment = segmentUrlMap[index]; // See DASH spec section 5.3.9.2.2\n      // - if timescale isn't present on any level, default to 1.\n\n      const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n      const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n      segment.timeline = segmentTime.timeline;\n      segment.duration = segmentTime.duration;\n      segment.number = segmentTime.number;\n      segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;\n      return segment;\n    } // Since we're mapping we should get rid of any blank segments (in case\n    // the given SegmentTimeline is handling for more elements than we have\n    // SegmentURLs for).\n  }).filter(segment => segment);\n  return segments;\n};\nconst generateSegments = _ref16 => {\n  let {\n    attributes,\n    segmentInfo\n  } = _ref16;\n  let segmentAttributes;\n  let segmentsFn;\n  if (segmentInfo.template) {\n    segmentsFn = segmentsFromTemplate;\n    segmentAttributes = merge(attributes, segmentInfo.template);\n  } else if (segmentInfo.base) {\n    segmentsFn = segmentsFromBase;\n    segmentAttributes = merge(attributes, segmentInfo.base);\n  } else if (segmentInfo.list) {\n    segmentsFn = segmentsFromList;\n    segmentAttributes = merge(attributes, segmentInfo.list);\n  }\n  const segmentsInfo = {\n    attributes\n  };\n  if (!segmentsFn) {\n    return segmentsInfo;\n  }\n  const segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n  // must be in seconds. Since we've generated the segment list, we no longer need\n  // @duration to be in @timescale units, so we can convert it here.\n\n  if (segmentAttributes.duration) {\n    const {\n      duration,\n      timescale = 1\n    } = segmentAttributes;\n    segmentAttributes.duration = duration / timescale;\n  } else if (segments.length) {\n    // if there is no @duration attribute, use the largest segment duration as\n    // as target duration\n    segmentAttributes.duration = segments.reduce((max, segment) => {\n      return Math.max(max, Math.ceil(segment.duration));\n    }, 0);\n  } else {\n    segmentAttributes.duration = 0;\n  }\n  segmentsInfo.attributes = segmentAttributes;\n  segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n\n  if (segmentInfo.base && segmentAttributes.indexRange) {\n    segmentsInfo.sidx = segments[0];\n    segmentsInfo.segments = [];\n  }\n  return segmentsInfo;\n};\nconst toPlaylists = representations => representations.map(generateSegments);\nconst findChildren = (element, name) => from(element.childNodes).filter(_ref17 => {\n  let {\n    tagName\n  } = _ref17;\n  return tagName === name;\n});\nconst getContent = element => element.textContent.trim();\n\n/**\n * Converts the provided string that may contain a division operation to a number.\n *\n * @param {string} value - the provided string value\n *\n * @return {number} the parsed string value\n */\nconst parseDivisionValue = value => {\n  return parseFloat(value.split('/').reduce((prev, current) => prev / current));\n};\nconst parseDuration = str => {\n  const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n  const SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n  const SECONDS_IN_DAY = 24 * 60 * 60;\n  const SECONDS_IN_HOUR = 60 * 60;\n  const SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n  const durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n  const match = durationRegex.exec(str);\n  if (!match) {\n    return 0;\n  }\n  const [year, month, day, hour, minute, second] = match.slice(1);\n  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n};\nconst parseDate = str => {\n  // Date format without timezone according to ISO 8601\n  // YYY-MM-DDThh:mm:ss.ssssss\n  const dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n  // expressed by ending with 'Z'\n\n  if (dateRegex.test(str)) {\n    str += 'Z';\n  }\n  return Date.parse(str);\n};\nconst parsers = {\n  /**\n   * Specifies the duration of the entire Media Presentation. Format is a duration string\n   * as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  mediaPresentationDuration(value) {\n    return parseDuration(value);\n  },\n  /**\n   * Specifies the Segment availability start time for all Segments referred to in this\n   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n   * time. Format is a date string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The date as seconds from unix epoch\n   */\n  availabilityStartTime(value) {\n    return parseDate(value) / 1000;\n  },\n  /**\n   * Specifies the smallest period between potential changes to the MPD. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  minimumUpdatePeriod(value) {\n    return parseDuration(value);\n  },\n  /**\n   * Specifies the suggested presentation delay. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  suggestedPresentationDelay(value) {\n    return parseDuration(value);\n  },\n  /**\n   * specifices the type of mpd. Can be either \"static\" or \"dynamic\"\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   *\n   * @return {string}\n   *         The type as a string\n   */\n  type(value) {\n    return value;\n  },\n  /**\n   * Specifies the duration of the smallest time shifting buffer for any Representation\n   * in the MPD. Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  timeShiftBufferDepth(value) {\n    return parseDuration(value);\n  },\n  /**\n   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n   * Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  start(value) {\n    return parseDuration(value);\n  },\n  /**\n   * Specifies the width of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed width\n   */\n  width(value) {\n    return parseInt(value, 10);\n  },\n  /**\n   * Specifies the height of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed height\n   */\n  height(value) {\n    return parseInt(value, 10);\n  },\n  /**\n   * Specifies the bitrate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed bandwidth\n   */\n  bandwidth(value) {\n    return parseInt(value, 10);\n  },\n  /**\n   * Specifies the frame rate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed frame rate\n   */\n  frameRate(value) {\n    return parseDivisionValue(value);\n  },\n  /**\n   * Specifies the number of the first Media Segment in this Representation in the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  startNumber(value) {\n    return parseInt(value, 10);\n  },\n  /**\n   * Specifies the timescale in units per seconds\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed timescale\n   */\n  timescale(value) {\n    return parseInt(value, 10);\n  },\n  /**\n   * Specifies the presentationTimeOffset.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTimeOffset\n   */\n  presentationTimeOffset(value) {\n    return parseInt(value, 10);\n  },\n  /**\n   * Specifies the constant approximate Segment duration\n   * NOTE: The <Period> element also contains an @duration attribute. This duration\n   *       specifies the duration of the Period. This attribute is currently not\n   *       supported by the rest of the parser, however we still check for it to prevent\n   *       errors.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  duration(value) {\n    const parsedValue = parseInt(value, 10);\n    if (isNaN(parsedValue)) {\n      return parseDuration(value);\n    }\n    return parsedValue;\n  },\n  /**\n   * Specifies the Segment duration, in units of the value of the @timescale.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  d(value) {\n    return parseInt(value, 10);\n  },\n  /**\n   * Specifies the MPD start time, in @timescale units, the first Segment in the series\n   * starts relative to the beginning of the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed time\n   */\n  t(value) {\n    return parseInt(value, 10);\n  },\n  /**\n   * Specifies the repeat count of the number of following contiguous Segments with the\n   * same duration expressed by the value of @d\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  r(value) {\n    return parseInt(value, 10);\n  },\n  /**\n   * Default parser for all other attributes. Acts as a no-op and just returns the value\n   * as a string\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {string}\n   *         Unparsed value\n   */\n  DEFAULT(value) {\n    return value;\n  }\n};\n/**\n * Gets all the attributes and values of the provided node, parses attributes with known\n * types, and returns an object with attribute names mapped to values.\n *\n * @param {Node} el\n *        The node to parse attributes from\n * @return {Object}\n *         Object with all attributes of el parsed\n */\n\nconst parseAttributes = el => {\n  if (!(el && el.attributes)) {\n    return {};\n  }\n  return from(el.attributes).reduce((a, e) => {\n    const parseFn = parsers[e.name] || parsers.DEFAULT;\n    a[e.name] = parseFn(e.value);\n    return a;\n  }, {});\n};\nconst keySystemsMap = {\n  'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n  'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n  'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'\n};\n/**\n * Builds a list of urls that is the product of the reference urls and BaseURL values\n *\n * @param {string[]} referenceUrls\n *        List of reference urls to resolve to\n * @param {Node[]} baseUrlElements\n *        List of BaseURL nodes from the mpd\n * @return {string[]}\n *         List of resolved urls\n */\n\nconst buildBaseUrls = (referenceUrls, baseUrlElements) => {\n  if (!baseUrlElements.length) {\n    return referenceUrls;\n  }\n  return flatten(referenceUrls.map(function (reference) {\n    return baseUrlElements.map(function (baseUrlElement) {\n      return resolveUrl(reference, getContent(baseUrlElement));\n    });\n  }));\n};\n/**\n * Contains all Segment information for its containing AdaptationSet\n *\n * @typedef {Object} SegmentInformation\n * @property {Object|undefined} template\n *           Contains the attributes for the SegmentTemplate node\n * @property {Object[]|undefined} segmentTimeline\n *           Contains a list of atrributes for each S node within the SegmentTimeline node\n * @property {Object|undefined} list\n *           Contains the attributes for the SegmentList node\n * @property {Object|undefined} base\n *           Contains the attributes for the SegmentBase node\n */\n\n/**\n * Returns all available Segment information contained within the AdaptationSet node\n *\n * @param {Node} adaptationSet\n *        The AdaptationSet node to get Segment information from\n * @return {SegmentInformation}\n *         The Segment information contained within the provided AdaptationSet\n */\n\nconst getSegmentInformation = adaptationSet => {\n  const segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n  const segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n  const segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(s => merge({\n    tag: 'SegmentURL'\n  }, parseAttributes(s)));\n  const segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n  const segmentTimelineParentNode = segmentList || segmentTemplate;\n  const segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n  const segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n  const segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n  // @initialization and an <Initialization> node.  @initialization can be templated,\n  // while the node can have a url and range specified.  If the <SegmentTemplate> has\n  // both @initialization and an <Initialization> subelement we opt to override with\n  // the node, as this interaction is not defined in the spec.\n\n  const template = segmentTemplate && parseAttributes(segmentTemplate);\n  if (template && segmentInitialization) {\n    template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n  } else if (template && template.initialization) {\n    // If it is @initialization we convert it to an object since this is the format that\n    // later functions will rely on for the initialization segment.  This is only valid\n    // for <SegmentTemplate>\n    template.initialization = {\n      sourceURL: template.initialization\n    };\n  }\n  const segmentInfo = {\n    template,\n    segmentTimeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(s => parseAttributes(s)),\n    list: segmentList && merge(parseAttributes(segmentList), {\n      segmentUrls,\n      initialization: parseAttributes(segmentInitialization)\n    }),\n    base: segmentBase && merge(parseAttributes(segmentBase), {\n      initialization: parseAttributes(segmentInitialization)\n    })\n  };\n  Object.keys(segmentInfo).forEach(key => {\n    if (!segmentInfo[key]) {\n      delete segmentInfo[key];\n    }\n  });\n  return segmentInfo;\n};\n/**\n * Contains Segment information and attributes needed to construct a Playlist object\n * from a Representation\n *\n * @typedef {Object} RepresentationInformation\n * @property {SegmentInformation} segmentInfo\n *           Segment information for this Representation\n * @property {Object} attributes\n *           Inherited attributes for this Representation\n */\n\n/**\n * Maps a Representation node to an object containing Segment information and attributes\n *\n * @name inheritBaseUrlsCallback\n * @function\n * @param {Node} representation\n *        Representation node from the mpd\n * @return {RepresentationInformation}\n *         Representation information needed to construct a Playlist object\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Representation nodes to\n * Segment information and attributes using inherited BaseURL nodes.\n *\n * @param {Object} adaptationSetAttributes\n *        Contains attributes inherited by the AdaptationSet\n * @param {string[]} adaptationSetBaseUrls\n *        Contains list of resolved base urls inherited by the AdaptationSet\n * @param {SegmentInformation} adaptationSetSegmentInfo\n *        Contains Segment information for the AdaptationSet\n * @return {inheritBaseUrlsCallback}\n *         Callback map function\n */\n\nconst inheritBaseUrls = (adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) => representation => {\n  const repBaseUrlElements = findChildren(representation, 'BaseURL');\n  const repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n  const attributes = merge(adaptationSetAttributes, parseAttributes(representation));\n  const representationSegmentInfo = getSegmentInformation(representation);\n  return repBaseUrls.map(baseUrl => {\n    return {\n      segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\n      attributes: merge(attributes, {\n        baseUrl\n      })\n    };\n  });\n};\n/**\n * Tranforms a series of content protection nodes to\n * an object containing pssh data by key system\n *\n * @param {Node[]} contentProtectionNodes\n *        Content protection nodes\n * @return {Object}\n *        Object containing pssh data by key system\n */\n\nconst generateKeySystemInformation = contentProtectionNodes => {\n  return contentProtectionNodes.reduce((acc, node) => {\n    const attributes = parseAttributes(node); // Although it could be argued that according to the UUID RFC spec the UUID string (a-f chars) should be generated\n    // as a lowercase string it also mentions it should be treated as case-insensitive on input. Since the key system\n    // UUIDs in the keySystemsMap are hardcoded as lowercase in the codebase there isn't any reason not to do\n    // .toLowerCase() on the input UUID string from the manifest (at least I could not think of one).\n\n    if (attributes.schemeIdUri) {\n      attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();\n    }\n    const keySystem = keySystemsMap[attributes.schemeIdUri];\n    if (keySystem) {\n      acc[keySystem] = {\n        attributes\n      };\n      const psshNode = findChildren(node, 'cenc:pssh')[0];\n      if (psshNode) {\n        const pssh = getContent(psshNode);\n        acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);\n      }\n    }\n    return acc;\n  }, {});\n}; // defined in ANSI_SCTE 214-1 2016\n\nconst parseCaptionServiceMetadata = service => {\n  // 608 captions\n  if (service.schemeIdUri === 'urn:scte:dash:cc:cea-608:2015') {\n    const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(value => {\n      let channel;\n      let language; // default language to value\n\n      language = value;\n      if (/^CC\\d=/.test(value)) {\n        [channel, language] = value.split('=');\n      } else if (/^CC\\d$/.test(value)) {\n        channel = value;\n      }\n      return {\n        channel,\n        language\n      };\n    });\n  } else if (service.schemeIdUri === 'urn:scte:dash:cc:cea-708:2015') {\n    const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(value => {\n      const flags = {\n        // service or channel number 1-63\n        'channel': undefined,\n        // language is a 3ALPHA per ISO 639.2/B\n        // field is required\n        'language': undefined,\n        // BIT 1/0 or ?\n        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown\n        'aspectRatio': 1,\n        // BIT 1/0\n        // easy reader flag indicated the text is tailed to the needs of beginning readers\n        // default 0, or off\n        'easyReader': 0,\n        // BIT 1/0\n        // If 3d metadata is present (CEA-708.1) then 1\n        // default 0\n        '3D': 0\n      };\n      if (/=/.test(value)) {\n        const [channel, opts = ''] = value.split('=');\n        flags.channel = channel;\n        flags.language = value;\n        opts.split(',').forEach(opt => {\n          const [name, val] = opt.split(':');\n          if (name === 'lang') {\n            flags.language = val; // er for easyReadery\n          } else if (name === 'er') {\n            flags.easyReader = Number(val); // war for wide aspect ratio\n          } else if (name === 'war') {\n            flags.aspectRatio = Number(val);\n          } else if (name === '3D') {\n            flags['3D'] = Number(val);\n          }\n        });\n      } else {\n        flags.language = value;\n      }\n      if (flags.channel) {\n        flags.channel = 'SERVICE' + flags.channel;\n      }\n      return flags;\n    });\n  }\n};\n/**\n * Maps an AdaptationSet node to a list of Representation information objects\n *\n * @name toRepresentationsCallback\n * @function\n * @param {Node} adaptationSet\n *        AdaptationSet node from the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n * Representation information objects\n *\n * @param {Object} periodAttributes\n *        Contains attributes inherited by the Period\n * @param {string[]} periodBaseUrls\n *        Contains list of resolved base urls inherited by the Period\n * @param {string[]} periodSegmentInfo\n *        Contains Segment Information at the period level\n * @return {toRepresentationsCallback}\n *         Callback map function\n */\n\nconst toRepresentations = (periodAttributes, periodBaseUrls, periodSegmentInfo) => adaptationSet => {\n  const adaptationSetAttributes = parseAttributes(adaptationSet);\n  const adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n  const role = findChildren(adaptationSet, 'Role')[0];\n  const roleAttributes = {\n    role: parseAttributes(role)\n  };\n  let attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\n  const accessibility = findChildren(adaptationSet, 'Accessibility')[0];\n  const captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));\n  if (captionServices) {\n    attrs = merge(attrs, {\n      captionServices\n    });\n  }\n  const label = findChildren(adaptationSet, 'Label')[0];\n  if (label && label.childNodes.length) {\n    const labelVal = label.childNodes[0].nodeValue.trim();\n    attrs = merge(attrs, {\n      label: labelVal\n    });\n  }\n  const contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n  if (Object.keys(contentProtection).length) {\n    attrs = merge(attrs, {\n      contentProtection\n    });\n  }\n  const segmentInfo = getSegmentInformation(adaptationSet);\n  const representations = findChildren(adaptationSet, 'Representation');\n  const adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\n  return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n};\n/**\n * Contains all period information for mapping nodes onto adaptation sets.\n *\n * @typedef {Object} PeriodInformation\n * @property {Node} period.node\n *           Period node from the mpd\n * @property {Object} period.attributes\n *           Parsed period attributes from node plus any added\n */\n\n/**\n * Maps a PeriodInformation object to a list of Representation information objects for all\n * AdaptationSet nodes contained within the Period.\n *\n * @name toAdaptationSetsCallback\n * @function\n * @param {PeriodInformation} period\n *        Period object containing necessary period information\n * @param {number} periodStart\n *        Start time of the Period within the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n * Representation information objects\n *\n * @param {Object} mpdAttributes\n *        Contains attributes inherited by the mpd\n * @param {string[]} mpdBaseUrls\n *        Contains list of resolved base urls inherited by the mpd\n * @return {toAdaptationSetsCallback}\n *         Callback map function\n */\n\nconst toAdaptationSets = (mpdAttributes, mpdBaseUrls) => (period, index) => {\n  const periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, 'BaseURL'));\n  const periodAttributes = merge(mpdAttributes, {\n    periodStart: period.attributes.start\n  });\n  if (typeof period.attributes.duration === 'number') {\n    periodAttributes.periodDuration = period.attributes.duration;\n  }\n  const adaptationSets = findChildren(period.node, 'AdaptationSet');\n  const periodSegmentInfo = getSegmentInformation(period.node);\n  return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n};\n/**\n * Gets Period@start property for a given period.\n *\n * @param {Object} options\n *        Options object\n * @param {Object} options.attributes\n *        Period attributes\n * @param {Object} [options.priorPeriodAttributes]\n *        Prior period attributes (if prior period is available)\n * @param {string} options.mpdType\n *        The MPD@type these periods came from\n * @return {number|null}\n *         The period start, or null if it's an early available period or error\n */\n\nconst getPeriodStart = _ref18 => {\n  let {\n    attributes,\n    priorPeriodAttributes,\n    mpdType\n  } = _ref18;\n  // Summary of period start time calculation from DASH spec section 5.3.2.1\n  //\n  // A period's start is the first period's start + time elapsed after playing all\n  // prior periods to this one. Periods continue one after the other in time (without\n  // gaps) until the end of the presentation.\n  //\n  // The value of Period@start should be:\n  // 1. if Period@start is present: value of Period@start\n  // 2. if previous period exists and it has @duration: previous Period@start +\n  //    previous Period@duration\n  // 3. if this is first period and MPD@type is 'static': 0\n  // 4. in all other cases, consider the period an \"early available period\" (note: not\n  //    currently supported)\n  // (1)\n  if (typeof attributes.start === 'number') {\n    return attributes.start;\n  } // (2)\n\n  if (priorPeriodAttributes && typeof priorPeriodAttributes.start === 'number' && typeof priorPeriodAttributes.duration === 'number') {\n    return priorPeriodAttributes.start + priorPeriodAttributes.duration;\n  } // (3)\n\n  if (!priorPeriodAttributes && mpdType === 'static') {\n    return 0;\n  } // (4)\n  // There is currently no logic for calculating the Period@start value if there is\n  // no Period@start or prior Period@start and Period@duration available. This is not made\n  // explicit by the DASH interop guidelines or the DASH spec, however, since there's\n  // nothing about any other resolution strategies, it's implied. Thus, this case should\n  // be considered an early available period, or error, and null should suffice for both\n  // of those cases.\n\n  return null;\n};\n/**\n * Traverses the mpd xml tree to generate a list of Representation information objects\n * that have inherited attributes from parent nodes\n *\n * @param {Node} mpd\n *        The root node of the mpd\n * @param {Object} options\n *        Available options for inheritAttributes\n * @param {string} options.manifestUri\n *        The uri source of the mpd\n * @param {number} options.NOW\n *        Current time per DASH IOP.  Default is current time in ms since epoch\n * @param {number} options.clientOffset\n *        Client time difference from NOW (in milliseconds)\n * @return {RepresentationInformation[]}\n *         List of objects containing Representation information\n */\n\nconst inheritAttributes = function (mpd) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    manifestUri = '',\n    NOW = Date.now(),\n    clientOffset = 0\n  } = options;\n  const periodNodes = findChildren(mpd, 'Period');\n  if (!periodNodes.length) {\n    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n  }\n  const locations = findChildren(mpd, 'Location');\n  const mpdAttributes = parseAttributes(mpd);\n  const mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, 'BaseURL')); // See DASH spec section 5.3.1.2, Semantics of MPD element. Default type to 'static'.\n\n  mpdAttributes.type = mpdAttributes.type || 'static';\n  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n  mpdAttributes.NOW = NOW;\n  mpdAttributes.clientOffset = clientOffset;\n  if (locations.length) {\n    mpdAttributes.locations = locations.map(getContent);\n  }\n  const periods = []; // Since toAdaptationSets acts on individual periods right now, the simplest approach to\n  // adding properties that require looking at prior periods is to parse attributes and add\n  // missing ones before toAdaptationSets is called. If more such properties are added, it\n  // may be better to refactor toAdaptationSets.\n\n  periodNodes.forEach((node, index) => {\n    const attributes = parseAttributes(node); // Use the last modified prior period, as it may contain added information necessary\n    // for this period.\n\n    const priorPeriod = periods[index - 1];\n    attributes.start = getPeriodStart({\n      attributes,\n      priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,\n      mpdType: mpdAttributes.type\n    });\n    periods.push({\n      node,\n      attributes\n    });\n  });\n  return {\n    locations: mpdAttributes.locations,\n    representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)))\n  };\n};\nconst stringToMpdXml = manifestString => {\n  if (manifestString === '') {\n    throw new Error(errors.DASH_EMPTY_MANIFEST);\n  }\n  const parser = new DOMParser();\n  let xml;\n  let mpd;\n  try {\n    xml = parser.parseFromString(manifestString, 'application/xml');\n    mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n  } catch (e) {// ie 11 throwsw on invalid xml\n  }\n  if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n    throw new Error(errors.DASH_INVALID_XML);\n  }\n  return mpd;\n};\n\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} mpd\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\nconst parseUTCTimingScheme = mpd => {\n  const UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n  if (!UTCTimingNode) {\n    return null;\n  }\n  const attributes = parseAttributes(UTCTimingNode);\n  switch (attributes.schemeIdUri) {\n    case 'urn:mpeg:dash:utc:http-head:2014':\n    case 'urn:mpeg:dash:utc:http-head:2012':\n      attributes.method = 'HEAD';\n      break;\n    case 'urn:mpeg:dash:utc:http-xsdate:2014':\n    case 'urn:mpeg:dash:utc:http-iso:2014':\n    case 'urn:mpeg:dash:utc:http-xsdate:2012':\n    case 'urn:mpeg:dash:utc:http-iso:2012':\n      attributes.method = 'GET';\n      break;\n    case 'urn:mpeg:dash:utc:direct:2014':\n    case 'urn:mpeg:dash:utc:direct:2012':\n      attributes.method = 'DIRECT';\n      attributes.value = Date.parse(attributes.value);\n      break;\n    case 'urn:mpeg:dash:utc:http-ntp:2014':\n    case 'urn:mpeg:dash:utc:ntp:2014':\n    case 'urn:mpeg:dash:utc:sntp:2014':\n    default:\n      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n  }\n  return attributes;\n};\nconst VERSION = version;\n/*\n * Given a DASH manifest string and options, parses the DASH manifest into an object in the\n * form outputed by m3u8-parser and accepted by videojs/http-streaming.\n *\n * For live DASH manifests, if `previousManifest` is provided in options, then the newly\n * parsed DASH manifest will have its media sequence and discontinuity sequence values\n * updated to reflect its position relative to the prior manifest.\n *\n * @param {string} manifestString - the DASH manifest as a string\n * @param {options} [options] - any options\n *\n * @return {Object} the manifest object\n */\n\nconst parse = function (manifestString) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);\n  const playlists = toPlaylists(parsedManifestInfo.representationInfo);\n  return toM3u8({\n    dashPlaylists: playlists,\n    locations: parsedManifestInfo.locations,\n    sidxMapping: options.sidxMapping,\n    previousManifest: options.previousManifest\n  });\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} manifestString\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\nconst parseUTCTiming = manifestString => parseUTCTimingScheme(stringToMpdXml(manifestString));\nexport { VERSION, addSidxSegmentsToPlaylist$1 as addSidxSegmentsToPlaylist, generateSidxKey, inheritAttributes, parse, parseUTCTiming, stringToMpdXml, toM3u8, toPlaylists };","map":{"version":3,"names":["resolveUrl","window","forEachMediaGroup","decodeB64ToUint8Array","DOMParser","version","isObject","obj","merge","_len","arguments","length","objects","Array","_key","reduce","result","source","Object","keys","forEach","key","isArray","concat","values","o","map","k","range","start","end","i","push","flatten","lists","x","y","from","list","findIndexes","l","a","e","union","keyFunction","acc","el","errors","INVALID_NUMBER_OF_PERIOD","DASH_EMPTY_MANIFEST","DASH_INVALID_XML","NO_BASE_URL","MISSING_SEGMENT_INFORMATION","SEGMENT_TIME_UNSPECIFIED","UNSUPPORTED_UTC_TIMING_SCHEME","urlTypeToSegment","_ref","baseUrl","indexRange","segment","uri","resolvedUri","rangeStr","ranges","split","startRange","BigInt","parseInt","endRange","Number","MAX_SAFE_INTEGER","byterange","offset","byteRangeToString","parseEndNumber","endNumber","isNaN","segmentRange","static","attributes","duration","timescale","sourceDuration","periodDuration","segmentDuration","dynamic","NOW","clientOffset","availabilityStartTime","periodStart","minimumUpdatePeriod","timeShiftBufferDepth","Infinity","now","periodStartWC","periodEndWC","segmentCount","Math","ceil","availableStart","floor","availableEnd","max","min","toSegments","number","startNumber","timeline","time","parseByDuration","type","segments","index","sectionDuration","segmentsFromBase","initialization","presentationTime","Error","initSegment","sourceURL","segmentTimeInfo","addSidxSegmentsToPlaylist$1","playlist","sidx","sidxByteRange","sidxEnd","mediaReferences","references","filter","r","referenceType","endList","mediaSequence","startIndex","firstOffset","reference","size","referencedSize","subsegmentDuration","endIndex","SUPPORTED_MEDIA_TYPES","TIME_FUDGE","getUniqueTimelineStarts","timelineStarts","_ref2","sort","b","findPlaylistWithName","playlists","name","NAME","getMediaGroupPlaylists","manifest","mediaGroupPlaylists","properties","group","label","updateMediaSequenceForPlaylist","_ref3","updateSequenceNumbers","_ref4","oldPlaylists","newPlaylists","discontinuitySequence","findIndex","_ref5","oldPlaylist","firstNewSegment","oldMatchingSegmentIndex","oldSegment","abs","discontinuity","discontinuityStarts","unshift","oldMatchingSegment","positionManifestOnTimeline","_ref6","oldManifest","newManifest","generateSidxKey","mergeDiscontiguousPlaylists","mergedPlaylists","id","lang","contentProtection","addSidxSegmentsToPlaylist","sidxMapping","sidxKey","sidxMatch","addSidxSegmentsToPlaylists","undefined","formatAudioPlaylist","_ref7","isAudioOnly","BANDWIDTH","bandwidth","CODECS","codecs","targetDuration","AUDIO","SUBTITLES","formatVttPlaylist","_ref8","m3u8Attributes","organizeAudioPlaylists","mainPlaylist","formattedPlaylists","role","value","language","roleLabel","autoselect","default","formatted","firstLabel","organizeVttPlaylists","organizeCaptionServices","captionServices","svcObj","svc","service","channel","instreamId","hasOwnProperty","aspectRatio","easyReader","formatVideoPlaylist","_ref9","RESOLUTION","width","height","frameRate","videoOnly","_ref10","mimeType","contentType","audioOnly","_ref11","vttOnly","_ref12","addMediaSequenceValues","_ref13","flattenMediaGroupPlaylists","mediaGroupObject","labelContents","toM3u8","_ref14","dashPlaylists","locations","previousManifest","suggestedPresentationDelay","videoPlaylists","audioPlaylists","vttPlaylists","captions","Boolean","allowCache","mediaGroups","VIDEO","organizedAudioGroup","organizedVttGroup","playlistTimelineStarts","_ref15","audio","subs","cc","getLiveRValue","parseByTimeline","segmentTimeline","media","sIndex","S","d","repeat","segmentTime","t","count","nextS","indexOf","identifierPattern","identifierReplacement","match","identifier","format","join","constructTemplateUrl","url","replace","parseTemplateInfo","segmentsFromTemplate","templateValues","RepresentationID","Bandwidth","mapSegment","Time","presentationTimeOffset","SegmentURLToSegmentObject","segmentUrl","mediaRange","segmentsFromList","segmentUrls","segmentUrlMap","segmentUrlObject","generateSegments","_ref16","segmentInfo","segmentAttributes","segmentsFn","template","base","segmentsInfo","toPlaylists","representations","findChildren","element","childNodes","_ref17","tagName","getContent","textContent","trim","parseDivisionValue","parseFloat","prev","current","parseDuration","str","SECONDS_IN_YEAR","SECONDS_IN_MONTH","SECONDS_IN_DAY","SECONDS_IN_HOUR","SECONDS_IN_MIN","durationRegex","exec","year","month","day","hour","minute","second","slice","parseDate","dateRegex","test","Date","parse","parsers","mediaPresentationDuration","parsedValue","DEFAULT","parseAttributes","parseFn","keySystemsMap","buildBaseUrls","referenceUrls","baseUrlElements","baseUrlElement","getSegmentInformation","adaptationSet","segmentTemplate","segmentList","s","tag","segmentBase","segmentTimelineParentNode","segmentInitializationParentNode","segmentInitialization","inheritBaseUrls","adaptationSetAttributes","adaptationSetBaseUrls","adaptationSetSegmentInfo","representation","repBaseUrlElements","repBaseUrls","representationSegmentInfo","generateKeySystemInformation","contentProtectionNodes","node","schemeIdUri","toLowerCase","keySystem","psshNode","pssh","parseCaptionServiceMetadata","flags","opts","opt","val","toRepresentations","periodAttributes","periodBaseUrls","periodSegmentInfo","roleAttributes","attrs","accessibility","labelVal","nodeValue","toAdaptationSets","mpdAttributes","mpdBaseUrls","period","adaptationSets","getPeriodStart","_ref18","priorPeriodAttributes","mpdType","inheritAttributes","mpd","options","manifestUri","periodNodes","periods","priorPeriod","representationInfo","stringToMpdXml","manifestString","parser","xml","parseFromString","documentElement","getElementsByTagName","parseUTCTimingScheme","UTCTimingNode","method","VERSION","parsedManifestInfo","parseUTCTiming"],"sources":["/Users/cedric/Desktop/projects/video_player_uploader-master/frontend-app/node_modules/mpd-parser/dist/mpd-parser.es.js"],"sourcesContent":["/*! @name mpd-parser @version 1.0.1 @license Apache-2.0 */\nimport resolveUrl from '@videojs/vhs-utils/es/resolve-url';\nimport window from 'global/window';\nimport { forEachMediaGroup } from '@videojs/vhs-utils/es/media-groups';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/es/decode-b64-to-uint8-array';\nimport { DOMParser } from '@xmldom/xmldom';\n\nvar version = \"1.0.1\";\n\nconst isObject = obj => {\n  return !!obj && typeof obj === 'object';\n};\n\nconst merge = (...objects) => {\n  return objects.reduce((result, source) => {\n    if (typeof source !== 'object') {\n      return result;\n    }\n\n    Object.keys(source).forEach(key => {\n      if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n        result[key] = result[key].concat(source[key]);\n      } else if (isObject(result[key]) && isObject(source[key])) {\n        result[key] = merge(result[key], source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  }, {});\n};\nconst values = o => Object.keys(o).map(k => o[k]);\n\nconst range = (start, end) => {\n  const result = [];\n\n  for (let i = start; i < end; i++) {\n    result.push(i);\n  }\n\n  return result;\n};\nconst flatten = lists => lists.reduce((x, y) => x.concat(y), []);\nconst from = list => {\n  if (!list.length) {\n    return [];\n  }\n\n  const result = [];\n\n  for (let i = 0; i < list.length; i++) {\n    result.push(list[i]);\n  }\n\n  return result;\n};\nconst findIndexes = (l, key) => l.reduce((a, e, i) => {\n  if (e[key]) {\n    a.push(i);\n  }\n\n  return a;\n}, []);\n/**\n * Returns a union of the included lists provided each element can be identified by a key.\n *\n * @param {Array} list - list of lists to get the union of\n * @param {Function} keyFunction - the function to use as a key for each element\n *\n * @return {Array} the union of the arrays\n */\n\nconst union = (lists, keyFunction) => {\n  return values(lists.reduce((acc, list) => {\n    list.forEach(el => {\n      acc[keyFunction(el)] = el;\n    });\n    return acc;\n  }, {}));\n};\n\nvar errors = {\n  INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n  DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n  DASH_INVALID_XML: 'DASH_INVALID_XML',\n  NO_BASE_URL: 'NO_BASE_URL',\n  MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n  SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n  UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n};\n\n/**\n * @typedef {Object} SingleUri\n * @property {string} uri - relative location of segment\n * @property {string} resolvedUri - resolved location of segment\n * @property {Object} byterange - Object containing information on how to make byte range\n *   requests following byte-range-spec per RFC2616.\n * @property {String} byterange.length - length of range request\n * @property {String} byterange.offset - byte offset of range request\n *\n * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n */\n\n/**\n * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n * that conforms to how m3u8-parser is structured\n *\n * @see https://github.com/videojs/m3u8-parser\n *\n * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n * @param {string} source - source url for segment\n * @param {string} range - optional range used for range calls,\n *   follows  RFC 2616, Clause 14.35.1\n * @return {SingleUri} full segment information transformed into a format similar\n *   to m3u8-parser\n */\n\nconst urlTypeToSegment = ({\n  baseUrl = '',\n  source = '',\n  range = '',\n  indexRange = ''\n}) => {\n  const segment = {\n    uri: source,\n    resolvedUri: resolveUrl(baseUrl || '', source)\n  };\n\n  if (range || indexRange) {\n    const rangeStr = range ? range : indexRange;\n    const ranges = rangeStr.split('-'); // default to parsing this as a BigInt if possible\n\n    let startRange = window.BigInt ? window.BigInt(ranges[0]) : parseInt(ranges[0], 10);\n    let endRange = window.BigInt ? window.BigInt(ranges[1]) : parseInt(ranges[1], 10); // convert back to a number if less than MAX_SAFE_INTEGER\n\n    if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === 'bigint') {\n      startRange = Number(startRange);\n    }\n\n    if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === 'bigint') {\n      endRange = Number(endRange);\n    }\n\n    let length;\n\n    if (typeof endRange === 'bigint' || typeof startRange === 'bigint') {\n      length = window.BigInt(endRange) - window.BigInt(startRange) + window.BigInt(1);\n    } else {\n      length = endRange - startRange + 1;\n    }\n\n    if (typeof length === 'bigint' && length < Number.MAX_SAFE_INTEGER) {\n      length = Number(length);\n    } // byterange should be inclusive according to\n    // RFC 2616, Clause 14.35.1\n\n\n    segment.byterange = {\n      length,\n      offset: startRange\n    };\n  }\n\n  return segment;\n};\nconst byteRangeToString = byterange => {\n  // `endRange` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  let endRange;\n\n  if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n    endRange = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);\n  } else {\n    endRange = byterange.offset + byterange.length - 1;\n  }\n\n  return `${byterange.offset}-${endRange}`;\n};\n\n/**\n * parse the end number attribue that can be a string\n * number, or undefined.\n *\n * @param {string|number|undefined} endNumber\n *        The end number attribute.\n *\n * @return {number|null}\n *          The result of parsing the end number.\n */\n\nconst parseEndNumber = endNumber => {\n  if (endNumber && typeof endNumber !== 'number') {\n    endNumber = parseInt(endNumber, 10);\n  }\n\n  if (isNaN(endNumber)) {\n    return null;\n  }\n\n  return endNumber;\n};\n/**\n * Functions for calculating the range of available segments in static and dynamic\n * manifests.\n */\n\n\nconst segmentRange = {\n  /**\n   * Returns the entire range of available segments for a static MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  static(attributes) {\n    const {\n      duration,\n      timescale = 1,\n      sourceDuration,\n      periodDuration\n    } = attributes;\n    const endNumber = parseEndNumber(attributes.endNumber);\n    const segmentDuration = duration / timescale;\n\n    if (typeof endNumber === 'number') {\n      return {\n        start: 0,\n        end: endNumber\n      };\n    }\n\n    if (typeof periodDuration === 'number') {\n      return {\n        start: 0,\n        end: periodDuration / segmentDuration\n      };\n    }\n\n    return {\n      start: 0,\n      end: sourceDuration / segmentDuration\n    };\n  },\n\n  /**\n   * Returns the current live window range of available segments for a dynamic MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  dynamic(attributes) {\n    const {\n      NOW,\n      clientOffset,\n      availabilityStartTime,\n      timescale = 1,\n      duration,\n      periodStart = 0,\n      minimumUpdatePeriod = 0,\n      timeShiftBufferDepth = Infinity\n    } = attributes;\n    const endNumber = parseEndNumber(attributes.endNumber); // clientOffset is passed in at the top level of mpd-parser and is an offset calculated\n    // after retrieving UTC server time.\n\n    const now = (NOW + clientOffset) / 1000; // WC stands for Wall Clock.\n    // Convert the period start time to EPOCH.\n\n    const periodStartWC = availabilityStartTime + periodStart; // Period end in EPOCH is manifest's retrieval time + time until next update.\n\n    const periodEndWC = now + minimumUpdatePeriod;\n    const periodDuration = periodEndWC - periodStartWC;\n    const segmentCount = Math.ceil(periodDuration * timescale / duration);\n    const availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n    const availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n    return {\n      start: Math.max(0, availableStart),\n      end: typeof endNumber === 'number' ? endNumber : Math.min(segmentCount, availableEnd)\n    };\n  }\n\n};\n/**\n * Maps a range of numbers to objects with information needed to build the corresponding\n * segment list\n *\n * @name toSegmentsCallback\n * @function\n * @param {number} number\n *        Number of the segment\n * @param {number} index\n *        Index of the number in the range list\n * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n *         Object with segment timing and duration info\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping a range of numbers to\n * information needed to build the segment list.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {toSegmentsCallback}\n *         Callback map function\n */\n\nconst toSegments = attributes => number => {\n  const {\n    duration,\n    timescale = 1,\n    periodStart,\n    startNumber = 1\n  } = attributes;\n  return {\n    number: startNumber + number,\n    duration: duration / timescale,\n    timeline: periodStart,\n    time: number * duration\n  };\n};\n/**\n * Returns a list of objects containing segment timing and duration info used for\n * building the list of segments. This uses the @duration attribute specified\n * in the MPD manifest to derive the range of segments.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nconst parseByDuration = attributes => {\n  const {\n    type,\n    duration,\n    timescale = 1,\n    periodDuration,\n    sourceDuration\n  } = attributes;\n  const {\n    start,\n    end\n  } = segmentRange[type](attributes);\n  const segments = range(start, end).map(toSegments(attributes));\n\n  if (type === 'static') {\n    const index = segments.length - 1; // section is either a period or the full source\n\n    const sectionDuration = typeof periodDuration === 'number' ? periodDuration : sourceDuration; // final segment may be less than full segment duration\n\n    segments[index].duration = sectionDuration - duration / timescale * index;\n  }\n\n  return segments;\n};\n\n/**\n * Translates SegmentBase into a set of segments.\n * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @return {Object.<Array>} list of segments\n */\n\nconst segmentsFromBase = attributes => {\n  const {\n    baseUrl,\n    initialization = {},\n    sourceDuration,\n    indexRange = '',\n    periodStart,\n    presentationTime,\n    number = 0,\n    duration\n  } = attributes; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n  if (!baseUrl) {\n    throw new Error(errors.NO_BASE_URL);\n  }\n\n  const initSegment = urlTypeToSegment({\n    baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  const segment = urlTypeToSegment({\n    baseUrl,\n    source: baseUrl,\n    indexRange\n  });\n  segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n  // (since SegmentBase is only for one total segment)\n\n  if (duration) {\n    const segmentTimeInfo = parseByDuration(attributes);\n\n    if (segmentTimeInfo.length) {\n      segment.duration = segmentTimeInfo[0].duration;\n      segment.timeline = segmentTimeInfo[0].timeline;\n    }\n  } else if (sourceDuration) {\n    segment.duration = sourceDuration;\n    segment.timeline = periodStart;\n  } // If presentation time is provided, these segments are being generated by SIDX\n  // references, and should use the time provided. For the general case of SegmentBase,\n  // there should only be one segment in the period, so its presentation time is the same\n  // as its period start.\n\n\n  segment.presentationTime = presentationTime || periodStart;\n  segment.number = number;\n  return [segment];\n};\n/**\n * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n * according to the sidx information given.\n *\n * playlist.sidx has metadadata about the sidx where-as the sidx param\n * is the parsed sidx box itself.\n *\n * @param {Object} playlist the playlist to update the sidx information for\n * @param {Object} sidx the parsed sidx box\n * @return {Object} the playlist object with the updated sidx information\n */\n\nconst addSidxSegmentsToPlaylist$1 = (playlist, sidx, baseUrl) => {\n  // Retain init segment information\n  const initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial main manifest parsing\n\n  const sourceDuration = playlist.sidx.duration; // Retain source timeline\n\n  const timeline = playlist.timeline || 0;\n  const sidxByteRange = playlist.sidx.byterange;\n  const sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n\n  const timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n\n  const mediaReferences = sidx.references.filter(r => r.referenceType !== 1);\n  const segments = [];\n  const type = playlist.endList ? 'static' : 'dynamic';\n  const periodStart = playlist.sidx.timeline;\n  let presentationTime = periodStart;\n  let number = playlist.mediaSequence || 0; // firstOffset is the offset from the end of the sidx box\n\n  let startIndex; // eslint-disable-next-line\n\n  if (typeof sidx.firstOffset === 'bigint') {\n    startIndex = window.BigInt(sidxEnd) + sidx.firstOffset;\n  } else {\n    startIndex = sidxEnd + sidx.firstOffset;\n  }\n\n  for (let i = 0; i < mediaReferences.length; i++) {\n    const reference = sidx.references[i]; // size of the referenced (sub)segment\n\n    const size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n    // this will be converted to seconds when generating segments\n\n    const duration = reference.subsegmentDuration; // should be an inclusive range\n\n    let endIndex; // eslint-disable-next-line\n\n    if (typeof startIndex === 'bigint') {\n      endIndex = startIndex + window.BigInt(size) - window.BigInt(1);\n    } else {\n      endIndex = startIndex + size - 1;\n    }\n\n    const indexRange = `${startIndex}-${endIndex}`;\n    const attributes = {\n      baseUrl,\n      timescale,\n      timeline,\n      periodStart,\n      presentationTime,\n      number,\n      duration,\n      sourceDuration,\n      indexRange,\n      type\n    };\n    const segment = segmentsFromBase(attributes)[0];\n\n    if (initSegment) {\n      segment.map = initSegment;\n    }\n\n    segments.push(segment);\n\n    if (typeof startIndex === 'bigint') {\n      startIndex += window.BigInt(size);\n    } else {\n      startIndex += size;\n    }\n\n    presentationTime += duration / timescale;\n    number++;\n  }\n\n  playlist.segments = segments;\n  return playlist;\n};\n\nconst SUPPORTED_MEDIA_TYPES = ['AUDIO', 'SUBTITLES']; // allow one 60fps frame as leniency (arbitrarily chosen)\n\nconst TIME_FUDGE = 1 / 60;\n/**\n * Given a list of timelineStarts, combines, dedupes, and sorts them.\n *\n * @param {TimelineStart[]} timelineStarts - list of timeline starts\n *\n * @return {TimelineStart[]} the combined and deduped timeline starts\n */\n\nconst getUniqueTimelineStarts = timelineStarts => {\n  return union(timelineStarts, ({\n    timeline\n  }) => timeline).sort((a, b) => a.timeline > b.timeline ? 1 : -1);\n};\n/**\n * Finds the playlist with the matching NAME attribute.\n *\n * @param {Array} playlists - playlists to search through\n * @param {string} name - the NAME attribute to search for\n *\n * @return {Object|null} the matching playlist object, or null\n */\n\nconst findPlaylistWithName = (playlists, name) => {\n  for (let i = 0; i < playlists.length; i++) {\n    if (playlists[i].attributes.NAME === name) {\n      return playlists[i];\n    }\n  }\n\n  return null;\n};\n/**\n * Gets a flattened array of media group playlists.\n *\n * @param {Object} manifest - the main manifest object\n *\n * @return {Array} the media group playlists\n */\n\nconst getMediaGroupPlaylists = manifest => {\n  let mediaGroupPlaylists = [];\n  forEachMediaGroup(manifest, SUPPORTED_MEDIA_TYPES, (properties, type, group, label) => {\n    mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);\n  });\n  return mediaGroupPlaylists;\n};\n/**\n * Updates the playlist's media sequence numbers.\n *\n * @param {Object} config - options object\n * @param {Object} config.playlist - the playlist to update\n * @param {number} config.mediaSequence - the mediaSequence number to start with\n */\n\nconst updateMediaSequenceForPlaylist = ({\n  playlist,\n  mediaSequence\n}) => {\n  playlist.mediaSequence = mediaSequence;\n  playlist.segments.forEach((segment, index) => {\n    segment.number = playlist.mediaSequence + index;\n  });\n};\n/**\n * Updates the media and discontinuity sequence numbers of newPlaylists given oldPlaylists\n * and a complete list of timeline starts.\n *\n * If no matching playlist is found, only the discontinuity sequence number of the playlist\n * will be updated.\n *\n * Since early available timelines are not supported, at least one segment must be present.\n *\n * @param {Object} config - options object\n * @param {Object[]} oldPlaylists - the old playlists to use as a reference\n * @param {Object[]} newPlaylists - the new playlists to update\n * @param {Object} timelineStarts - all timelineStarts seen in the stream to this point\n */\n\nconst updateSequenceNumbers = ({\n  oldPlaylists,\n  newPlaylists,\n  timelineStarts\n}) => {\n  newPlaylists.forEach(playlist => {\n    playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n      timeline\n    }) {\n      return timeline === playlist.timeline;\n    }); // Playlists NAMEs come from DASH Representation IDs, which are mandatory\n    // (see ISO_23009-1-2012 5.3.5.2).\n    //\n    // If the same Representation existed in a prior Period, it will retain the same NAME.\n\n    const oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);\n\n    if (!oldPlaylist) {\n      // Since this is a new playlist, the media sequence values can start from 0 without\n      // consequence.\n      return;\n    } // TODO better support for live SIDX\n    //\n    // As of this writing, mpd-parser does not support multiperiod SIDX (in live or VOD).\n    // This is evident by a playlist only having a single SIDX reference. In a multiperiod\n    // playlist there would need to be multiple SIDX references. In addition, live SIDX is\n    // not supported when the SIDX properties change on refreshes.\n    //\n    // In the future, if support needs to be added, the merging logic here can be called\n    // after SIDX references are resolved. For now, exit early to prevent exceptions being\n    // thrown due to undefined references.\n\n\n    if (playlist.sidx) {\n      return;\n    } // Since we don't yet support early available timelines, we don't need to support\n    // playlists with no segments.\n\n\n    const firstNewSegment = playlist.segments[0];\n    const oldMatchingSegmentIndex = oldPlaylist.segments.findIndex(function (oldSegment) {\n      return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;\n    }); // No matching segment from the old playlist means the entire playlist was refreshed.\n    // In this case the media sequence should account for this update, and the new segments\n    // should be marked as discontinuous from the prior content, since the last prior\n    // timeline was removed.\n\n    if (oldMatchingSegmentIndex === -1) {\n      updateMediaSequenceForPlaylist({\n        playlist,\n        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length\n      });\n      playlist.segments[0].discontinuity = true;\n      playlist.discontinuityStarts.unshift(0); // No matching segment does not necessarily mean there's missing content.\n      //\n      // If the new playlist's timeline is the same as the last seen segment's timeline,\n      // then a discontinuity can be added to identify that there's potentially missing\n      // content. If there's no missing content, the discontinuity should still be rather\n      // harmless. It's possible that if segment durations are accurate enough, that the\n      // existence of a gap can be determined using the presentation times and durations,\n      // but if the segment timing info is off, it may introduce more problems than simply\n      // adding the discontinuity.\n      //\n      // If the new playlist's timeline is different from the last seen segment's timeline,\n      // then a discontinuity can be added to identify that this is the first seen segment\n      // of a new timeline. However, the logic at the start of this function that\n      // determined the disconinuity sequence by timeline index is now off by one (the\n      // discontinuity of the newest timeline hasn't yet fallen off the manifest...since\n      // we added it), so the disconinuity sequence must be decremented.\n      //\n      // A period may also have a duration of zero, so the case of no segments is handled\n      // here even though we don't yet support early available periods.\n\n      if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {\n        playlist.discontinuitySequence--;\n      }\n\n      return;\n    } // If the first segment matched with a prior segment on a discontinuity (it's matching\n    // on the first segment of a period), then the discontinuitySequence shouldn't be the\n    // timeline's matching one, but instead should be the one prior, and the first segment\n    // of the new manifest should be marked with a discontinuity.\n    //\n    // The reason for this special case is that discontinuity sequence shows how many\n    // discontinuities have fallen off of the playlist, and discontinuities are marked on\n    // the first segment of a new \"timeline.\" Because of this, while DASH will retain that\n    // Period while the \"timeline\" exists, HLS keeps track of it via the discontinuity\n    // sequence, and that first segment is an indicator, but can be removed before that\n    // timeline is gone.\n\n\n    const oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];\n\n    if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {\n      firstNewSegment.discontinuity = true;\n      playlist.discontinuityStarts.unshift(0);\n      playlist.discontinuitySequence--;\n    }\n\n    updateMediaSequenceForPlaylist({\n      playlist,\n      mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number\n    });\n  });\n};\n/**\n * Given an old parsed manifest object and a new parsed manifest object, updates the\n * sequence and timing values within the new manifest to ensure that it lines up with the\n * old.\n *\n * @param {Array} oldManifest - the old main manifest object\n * @param {Array} newManifest - the new main manifest object\n *\n * @return {Object} the updated new manifest object\n */\n\nconst positionManifestOnTimeline = ({\n  oldManifest,\n  newManifest\n}) => {\n  // Starting from v4.1.2 of the IOP, section 4.4.3.3 states:\n  //\n  // \"MPD@availabilityStartTime and Period@start shall not be changed over MPD updates.\"\n  //\n  // This was added from https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/160\n  //\n  // Because of this change, and the difficulty of supporting periods with changing start\n  // times, periods with changing start times are not supported. This makes the logic much\n  // simpler, since periods with the same start time can be considerred the same period\n  // across refreshes.\n  //\n  // To give an example as to the difficulty of handling periods where the start time may\n  // change, if a single period manifest is refreshed with another manifest with a single\n  // period, and both the start and end times are increased, then the only way to determine\n  // if it's a new period or an old one that has changed is to look through the segments of\n  // each playlist and determine the presentation time bounds to find a match. In addition,\n  // if the period start changed to exceed the old period end, then there would be no\n  // match, and it would not be possible to determine whether the refreshed period is a new\n  // one or the old one.\n  const oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));\n  const newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest)); // Save all seen timelineStarts to the new manifest. Although this potentially means that\n  // there's a \"memory leak\" in that it will never stop growing, in reality, only a couple\n  // of properties are saved for each seen Period. Even long running live streams won't\n  // generate too many Periods, unless the stream is watched for decades. In the future,\n  // this can be optimized by mapping to discontinuity sequence numbers for each timeline,\n  // but it may not become an issue, and the additional info can be useful for debugging.\n\n  newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);\n  updateSequenceNumbers({\n    oldPlaylists,\n    newPlaylists,\n    timelineStarts: newManifest.timelineStarts\n  });\n  return newManifest;\n};\n\nconst generateSidxKey = sidx => sidx && sidx.uri + '-' + byteRangeToString(sidx.byterange);\n\nconst mergeDiscontiguousPlaylists = playlists => {\n  const mergedPlaylists = values(playlists.reduce((acc, playlist) => {\n    // assuming playlist IDs are the same across periods\n    // TODO: handle multiperiod where representation sets are not the same\n    // across periods\n    const name = playlist.attributes.id + (playlist.attributes.lang || '');\n\n    if (!acc[name]) {\n      // First Period\n      acc[name] = playlist;\n      acc[name].attributes.timelineStarts = [];\n    } else {\n      // Subsequent Periods\n      if (playlist.segments) {\n        // first segment of subsequent periods signal a discontinuity\n        if (playlist.segments[0]) {\n          playlist.segments[0].discontinuity = true;\n        }\n\n        acc[name].segments.push(...playlist.segments);\n      } // bubble up contentProtection, this assumes all DRM content\n      // has the same contentProtection\n\n\n      if (playlist.attributes.contentProtection) {\n        acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n      }\n    }\n\n    acc[name].attributes.timelineStarts.push({\n      // Although they represent the same number, it's important to have both to make it\n      // compatible with HLS potentially having a similar attribute.\n      start: playlist.attributes.periodStart,\n      timeline: playlist.attributes.periodStart\n    });\n    return acc;\n  }, {}));\n  return mergedPlaylists.map(playlist => {\n    playlist.discontinuityStarts = findIndexes(playlist.segments || [], 'discontinuity');\n    return playlist;\n  });\n};\n\nconst addSidxSegmentsToPlaylist = (playlist, sidxMapping) => {\n  const sidxKey = generateSidxKey(playlist.sidx);\n  const sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n\n  if (sidxMatch) {\n    addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);\n  }\n\n  return playlist;\n};\nconst addSidxSegmentsToPlaylists = (playlists, sidxMapping = {}) => {\n  if (!Object.keys(sidxMapping).length) {\n    return playlists;\n  }\n\n  for (const i in playlists) {\n    playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);\n  }\n\n  return playlists;\n};\nconst formatAudioPlaylist = ({\n  attributes,\n  segments,\n  sidx,\n  mediaSequence,\n  discontinuitySequence,\n  discontinuityStarts\n}, isAudioOnly) => {\n  const playlist = {\n    attributes: {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth,\n      CODECS: attributes.codecs,\n      ['PROGRAM-ID']: 1\n    },\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    discontinuitySequence,\n    discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    mediaSequence,\n    segments\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  if (isAudioOnly) {\n    playlist.attributes.AUDIO = 'audio';\n    playlist.attributes.SUBTITLES = 'subs';\n  }\n\n  return playlist;\n};\nconst formatVttPlaylist = ({\n  attributes,\n  segments,\n  mediaSequence,\n  discontinuityStarts,\n  discontinuitySequence\n}) => {\n  if (typeof segments === 'undefined') {\n    // vtt tracks may use single file in BaseURL\n    segments = [{\n      uri: attributes.baseUrl,\n      timeline: attributes.periodStart,\n      resolvedUri: attributes.baseUrl || '',\n      duration: attributes.sourceDuration,\n      number: 0\n    }]; // targetDuration should be the same duration as the only segment\n\n    attributes.duration = attributes.sourceDuration;\n  }\n\n  const m3u8Attributes = {\n    NAME: attributes.id,\n    BANDWIDTH: attributes.bandwidth,\n    ['PROGRAM-ID']: 1\n  };\n\n  if (attributes.codecs) {\n    m3u8Attributes.CODECS = attributes.codecs;\n  }\n\n  return {\n    attributes: m3u8Attributes,\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    timelineStarts: attributes.timelineStarts,\n    discontinuityStarts,\n    discontinuitySequence,\n    mediaSequence,\n    segments\n  };\n};\nconst organizeAudioPlaylists = (playlists, sidxMapping = {}, isAudioOnly = false) => {\n  let mainPlaylist;\n  const formattedPlaylists = playlists.reduce((a, playlist) => {\n    const role = playlist.attributes.role && playlist.attributes.role.value || '';\n    const language = playlist.attributes.lang || '';\n    let label = playlist.attributes.label || 'main';\n\n    if (language && !playlist.attributes.label) {\n      const roleLabel = role ? ` (${role})` : '';\n      label = `${playlist.attributes.lang}${roleLabel}`;\n    }\n\n    if (!a[label]) {\n      a[label] = {\n        language,\n        autoselect: true,\n        default: role === 'main',\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    const formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);\n    a[label].playlists.push(formatted);\n\n    if (typeof mainPlaylist === 'undefined' && role === 'main') {\n      mainPlaylist = playlist;\n      mainPlaylist.default = true;\n    }\n\n    return a;\n  }, {}); // if no playlists have role \"main\", mark the first as main\n\n  if (!mainPlaylist) {\n    const firstLabel = Object.keys(formattedPlaylists)[0];\n    formattedPlaylists[firstLabel].default = true;\n  }\n\n  return formattedPlaylists;\n};\nconst organizeVttPlaylists = (playlists, sidxMapping = {}) => {\n  return playlists.reduce((a, playlist) => {\n    const label = playlist.attributes.lang || 'text';\n\n    if (!a[label]) {\n      a[label] = {\n        language: label,\n        default: false,\n        autoselect: false,\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));\n    return a;\n  }, {});\n};\n\nconst organizeCaptionServices = captionServices => captionServices.reduce((svcObj, svc) => {\n  if (!svc) {\n    return svcObj;\n  }\n\n  svc.forEach(service => {\n    const {\n      channel,\n      language\n    } = service;\n    svcObj[language] = {\n      autoselect: false,\n      default: false,\n      instreamId: channel,\n      language\n    };\n\n    if (service.hasOwnProperty('aspectRatio')) {\n      svcObj[language].aspectRatio = service.aspectRatio;\n    }\n\n    if (service.hasOwnProperty('easyReader')) {\n      svcObj[language].easyReader = service.easyReader;\n    }\n\n    if (service.hasOwnProperty('3D')) {\n      svcObj[language]['3D'] = service['3D'];\n    }\n  });\n  return svcObj;\n}, {});\n\nconst formatVideoPlaylist = ({\n  attributes,\n  segments,\n  sidx,\n  discontinuityStarts\n}) => {\n  const playlist = {\n    attributes: {\n      NAME: attributes.id,\n      AUDIO: 'audio',\n      SUBTITLES: 'subs',\n      RESOLUTION: {\n        width: attributes.width,\n        height: attributes.height\n      },\n      CODECS: attributes.codecs,\n      BANDWIDTH: attributes.bandwidth,\n      ['PROGRAM-ID']: 1\n    },\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    segments\n  };\n\n  if (attributes.frameRate) {\n    playlist.attributes['FRAME-RATE'] = attributes.frameRate;\n  }\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  return playlist;\n};\n\nconst videoOnly = ({\n  attributes\n}) => attributes.mimeType === 'video/mp4' || attributes.mimeType === 'video/webm' || attributes.contentType === 'video';\n\nconst audioOnly = ({\n  attributes\n}) => attributes.mimeType === 'audio/mp4' || attributes.mimeType === 'audio/webm' || attributes.contentType === 'audio';\n\nconst vttOnly = ({\n  attributes\n}) => attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n/**\n * Contains start and timeline properties denoting a timeline start. For DASH, these will\n * be the same number.\n *\n * @typedef {Object} TimelineStart\n * @property {number} start - the start time of the timeline\n * @property {number} timeline - the timeline number\n */\n\n/**\n * Adds appropriate media and discontinuity sequence values to the segments and playlists.\n *\n * Throughout mpd-parser, the `number` attribute is used in relation to `startNumber`, a\n * DASH specific attribute used in constructing segment URI's from templates. However, from\n * an HLS perspective, the `number` attribute on a segment would be its `mediaSequence`\n * value, which should start at the original media sequence value (or 0) and increment by 1\n * for each segment thereafter. Since DASH's `startNumber` values are independent per\n * period, it doesn't make sense to use it for `number`. Instead, assume everything starts\n * from a 0 mediaSequence value and increment from there.\n *\n * Note that VHS currently doesn't use the `number` property, but it can be helpful for\n * debugging and making sense of the manifest.\n *\n * For live playlists, to account for values increasing in manifests when periods are\n * removed on refreshes, merging logic should be used to update the numbers to their\n * appropriate values (to ensure they're sequential and increasing).\n *\n * @param {Object[]} playlists - the playlists to update\n * @param {TimelineStart[]} timelineStarts - the timeline starts for the manifest\n */\n\n\nconst addMediaSequenceValues = (playlists, timelineStarts) => {\n  // increment all segments sequentially\n  playlists.forEach(playlist => {\n    playlist.mediaSequence = 0;\n    playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n      timeline\n    }) {\n      return timeline === playlist.timeline;\n    });\n\n    if (!playlist.segments) {\n      return;\n    }\n\n    playlist.segments.forEach((segment, index) => {\n      segment.number = index;\n    });\n  });\n};\n/**\n * Given a media group object, flattens all playlists within the media group into a single\n * array.\n *\n * @param {Object} mediaGroupObject - the media group object\n *\n * @return {Object[]}\n *         The media group playlists\n */\n\nconst flattenMediaGroupPlaylists = mediaGroupObject => {\n  if (!mediaGroupObject) {\n    return [];\n  }\n\n  return Object.keys(mediaGroupObject).reduce((acc, label) => {\n    const labelContents = mediaGroupObject[label];\n    return acc.concat(labelContents.playlists);\n  }, []);\n};\nconst toM3u8 = ({\n  dashPlaylists,\n  locations,\n  sidxMapping = {},\n  previousManifest\n}) => {\n  if (!dashPlaylists.length) {\n    return {};\n  } // grab all main manifest attributes\n\n\n  const {\n    sourceDuration: duration,\n    type,\n    suggestedPresentationDelay,\n    minimumUpdatePeriod\n  } = dashPlaylists[0].attributes;\n  const videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n  const audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n  const vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));\n  const captions = dashPlaylists.map(playlist => playlist.attributes.captionServices).filter(Boolean);\n  const manifest = {\n    allowCache: true,\n    discontinuityStarts: [],\n    segments: [],\n    endList: true,\n    mediaGroups: {\n      AUDIO: {},\n      VIDEO: {},\n      ['CLOSED-CAPTIONS']: {},\n      SUBTITLES: {}\n    },\n    uri: '',\n    duration,\n    playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)\n  };\n\n  if (minimumUpdatePeriod >= 0) {\n    manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;\n  }\n\n  if (locations) {\n    manifest.locations = locations;\n  }\n\n  if (type === 'dynamic') {\n    manifest.suggestedPresentationDelay = suggestedPresentationDelay;\n  }\n\n  const isAudioOnly = manifest.playlists.length === 0;\n  const organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;\n  const organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;\n  const formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));\n  const playlistTimelineStarts = formattedPlaylists.map(({\n    timelineStarts\n  }) => timelineStarts);\n  manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);\n  addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);\n\n  if (organizedAudioGroup) {\n    manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;\n  }\n\n  if (organizedVttGroup) {\n    manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;\n  }\n\n  if (captions.length) {\n    manifest.mediaGroups['CLOSED-CAPTIONS'].cc = organizeCaptionServices(captions);\n  }\n\n  if (previousManifest) {\n    return positionManifestOnTimeline({\n      oldManifest: previousManifest,\n      newManifest: manifest\n    });\n  }\n\n  return manifest;\n};\n\n/**\n * Calculates the R (repetition) value for a live stream (for the final segment\n * in a manifest where the r value is negative 1)\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {number} time\n *        current time (typically the total time up until the final segment)\n * @param {number} duration\n *        duration property for the given <S />\n *\n * @return {number}\n *        R value to reach the end of the given period\n */\nconst getLiveRValue = (attributes, time, duration) => {\n  const {\n    NOW,\n    clientOffset,\n    availabilityStartTime,\n    timescale = 1,\n    periodStart = 0,\n    minimumUpdatePeriod = 0\n  } = attributes;\n  const now = (NOW + clientOffset) / 1000;\n  const periodStartWC = availabilityStartTime + periodStart;\n  const periodEndWC = now + minimumUpdatePeriod;\n  const periodDuration = periodEndWC - periodStartWC;\n  return Math.ceil((periodDuration * timescale - time) / duration);\n};\n/**\n * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n * timing and duration\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nconst parseByTimeline = (attributes, segmentTimeline) => {\n  const {\n    type,\n    minimumUpdatePeriod = 0,\n    media = '',\n    sourceDuration,\n    timescale = 1,\n    startNumber = 1,\n    periodStart: timeline\n  } = attributes;\n  const segments = [];\n  let time = -1;\n\n  for (let sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n    const S = segmentTimeline[sIndex];\n    const duration = S.d;\n    const repeat = S.r || 0;\n    const segmentTime = S.t || 0;\n\n    if (time < 0) {\n      // first segment\n      time = segmentTime;\n    }\n\n    if (segmentTime && segmentTime > time) {\n      // discontinuity\n      // TODO: How to handle this type of discontinuity\n      // timeline++ here would treat it like HLS discontuity and content would\n      // get appended without gap\n      // E.G.\n      //  <S t=\"0\" d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S t=\"5\" d=\"1\" />\n      // would have $Time$ values of [0, 1, 2, 5]\n      // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n      // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n      // does the value of sourceDuration consider this when calculating arbitrary\n      // negative @r repeat value?\n      // E.G. Same elements as above with this added at the end\n      //  <S d=\"1\" r=\"-1\" />\n      //  with a sourceDuration of 10\n      // Would the 2 gaps be included in the time duration calculations resulting in\n      // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n      // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n      time = segmentTime;\n    }\n\n    let count;\n\n    if (repeat < 0) {\n      const nextS = sIndex + 1;\n\n      if (nextS === segmentTimeline.length) {\n        // last segment\n        if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n          count = getLiveRValue(attributes, time, duration);\n        } else {\n          // TODO: This may be incorrect depending on conclusion of TODO above\n          count = (sourceDuration * timescale - time) / duration;\n        }\n      } else {\n        count = (segmentTimeline[nextS].t - time) / duration;\n      }\n    } else {\n      count = repeat + 1;\n    }\n\n    const end = startNumber + segments.length + count;\n    let number = startNumber + segments.length;\n\n    while (number < end) {\n      segments.push({\n        number,\n        duration: duration / timescale,\n        time,\n        timeline\n      });\n      time += duration;\n      number++;\n    }\n  }\n\n  return segments;\n};\n\nconst identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n/**\n * Replaces template identifiers with corresponding values. To be used as the callback\n * for String.prototype.replace\n *\n * @name replaceCallback\n * @function\n * @param {string} match\n *        Entire match of identifier\n * @param {string} identifier\n *        Name of matched identifier\n * @param {string} format\n *        Format tag string. Its presence indicates that padding is expected\n * @param {string} width\n *        Desired length of the replaced value. Values less than this width shall be left\n *        zero padded\n * @return {string}\n *         Replacement for the matched identifier\n */\n\n/**\n * Returns a function to be used as a callback for String.prototype.replace to replace\n * template identifiers\n *\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {replaceCallback}\n *         Callback to be used with String.prototype.replace to replace identifiers\n */\n\nconst identifierReplacement = values => (match, identifier, format, width) => {\n  if (match === '$$') {\n    // escape sequence\n    return '$';\n  }\n\n  if (typeof values[identifier] === 'undefined') {\n    return match;\n  }\n\n  const value = '' + values[identifier];\n\n  if (identifier === 'RepresentationID') {\n    // Format tag shall not be present with RepresentationID\n    return value;\n  }\n\n  if (!format) {\n    width = 1;\n  } else {\n    width = parseInt(width, 10);\n  }\n\n  if (value.length >= width) {\n    return value;\n  }\n\n  return `${new Array(width - value.length + 1).join('0')}${value}`;\n};\n/**\n * Constructs a segment url from a template string\n *\n * @param {string} url\n *        Template string to construct url from\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {string}\n *         Segment url with identifiers replaced\n */\n\nconst constructTemplateUrl = (url, values) => url.replace(identifierPattern, identifierReplacement(values));\n/**\n * Generates a list of objects containing timing and duration information about each\n * segment needed to generate segment uris and the complete segment object\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nconst parseTemplateInfo = (attributes, segmentTimeline) => {\n  if (!attributes.duration && !segmentTimeline) {\n    // if neither @duration or SegmentTimeline are present, then there shall be exactly\n    // one media segment\n    return [{\n      number: attributes.startNumber || 1,\n      duration: attributes.sourceDuration,\n      time: 0,\n      timeline: attributes.periodStart\n    }];\n  }\n\n  if (attributes.duration) {\n    return parseByDuration(attributes);\n  }\n\n  return parseByTimeline(attributes, segmentTimeline);\n};\n/**\n * Generates a list of segments using information provided by the SegmentTemplate element\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object[]}\n *         List of segment objects\n */\n\nconst segmentsFromTemplate = (attributes, segmentTimeline) => {\n  const templateValues = {\n    RepresentationID: attributes.id,\n    Bandwidth: attributes.bandwidth || 0\n  };\n  const {\n    initialization = {\n      sourceURL: '',\n      range: ''\n    }\n  } = attributes;\n  const mapSegment = urlTypeToSegment({\n    baseUrl: attributes.baseUrl,\n    source: constructTemplateUrl(initialization.sourceURL, templateValues),\n    range: initialization.range\n  });\n  const segments = parseTemplateInfo(attributes, segmentTimeline);\n  return segments.map(segment => {\n    templateValues.Number = segment.number;\n    templateValues.Time = segment.time;\n    const uri = constructTemplateUrl(attributes.media || '', templateValues); // See DASH spec section 5.3.9.2.2\n    // - if timescale isn't present on any level, default to 1.\n\n    const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n    const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n    const presentationTime = // Even if the @t attribute is not specified for the segment, segment.time is\n    // calculated in mpd-parser prior to this, so it's assumed to be available.\n    attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;\n    const map = {\n      uri,\n      timeline: segment.timeline,\n      duration: segment.duration,\n      resolvedUri: resolveUrl(attributes.baseUrl || '', uri),\n      map: mapSegment,\n      number: segment.number,\n      presentationTime\n    };\n    return map;\n  });\n};\n\n/**\n * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n * to an object that matches the output of a segment in videojs/mpd-parser\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object} segmentUrl\n *   <SegmentURL> node to translate into a segment object\n * @return {Object} translated segment object\n */\n\nconst SegmentURLToSegmentObject = (attributes, segmentUrl) => {\n  const {\n    baseUrl,\n    initialization = {}\n  } = attributes;\n  const initSegment = urlTypeToSegment({\n    baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  const segment = urlTypeToSegment({\n    baseUrl,\n    source: segmentUrl.media,\n    range: segmentUrl.mediaRange\n  });\n  segment.map = initSegment;\n  return segment;\n};\n/**\n * Generates a list of segments using information provided by the SegmentList element\n * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object.<Array>} list of segments\n */\n\n\nconst segmentsFromList = (attributes, segmentTimeline) => {\n  const {\n    duration,\n    segmentUrls = [],\n    periodStart\n  } = attributes; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n  // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n  if (!duration && !segmentTimeline || duration && segmentTimeline) {\n    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n  }\n\n  const segmentUrlMap = segmentUrls.map(segmentUrlObject => SegmentURLToSegmentObject(attributes, segmentUrlObject));\n  let segmentTimeInfo;\n\n  if (duration) {\n    segmentTimeInfo = parseByDuration(attributes);\n  }\n\n  if (segmentTimeline) {\n    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n  }\n\n  const segments = segmentTimeInfo.map((segmentTime, index) => {\n    if (segmentUrlMap[index]) {\n      const segment = segmentUrlMap[index]; // See DASH spec section 5.3.9.2.2\n      // - if timescale isn't present on any level, default to 1.\n\n      const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n      const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n      segment.timeline = segmentTime.timeline;\n      segment.duration = segmentTime.duration;\n      segment.number = segmentTime.number;\n      segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;\n      return segment;\n    } // Since we're mapping we should get rid of any blank segments (in case\n    // the given SegmentTimeline is handling for more elements than we have\n    // SegmentURLs for).\n\n  }).filter(segment => segment);\n  return segments;\n};\n\nconst generateSegments = ({\n  attributes,\n  segmentInfo\n}) => {\n  let segmentAttributes;\n  let segmentsFn;\n\n  if (segmentInfo.template) {\n    segmentsFn = segmentsFromTemplate;\n    segmentAttributes = merge(attributes, segmentInfo.template);\n  } else if (segmentInfo.base) {\n    segmentsFn = segmentsFromBase;\n    segmentAttributes = merge(attributes, segmentInfo.base);\n  } else if (segmentInfo.list) {\n    segmentsFn = segmentsFromList;\n    segmentAttributes = merge(attributes, segmentInfo.list);\n  }\n\n  const segmentsInfo = {\n    attributes\n  };\n\n  if (!segmentsFn) {\n    return segmentsInfo;\n  }\n\n  const segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n  // must be in seconds. Since we've generated the segment list, we no longer need\n  // @duration to be in @timescale units, so we can convert it here.\n\n  if (segmentAttributes.duration) {\n    const {\n      duration,\n      timescale = 1\n    } = segmentAttributes;\n    segmentAttributes.duration = duration / timescale;\n  } else if (segments.length) {\n    // if there is no @duration attribute, use the largest segment duration as\n    // as target duration\n    segmentAttributes.duration = segments.reduce((max, segment) => {\n      return Math.max(max, Math.ceil(segment.duration));\n    }, 0);\n  } else {\n    segmentAttributes.duration = 0;\n  }\n\n  segmentsInfo.attributes = segmentAttributes;\n  segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n\n  if (segmentInfo.base && segmentAttributes.indexRange) {\n    segmentsInfo.sidx = segments[0];\n    segmentsInfo.segments = [];\n  }\n\n  return segmentsInfo;\n};\nconst toPlaylists = representations => representations.map(generateSegments);\n\nconst findChildren = (element, name) => from(element.childNodes).filter(({\n  tagName\n}) => tagName === name);\nconst getContent = element => element.textContent.trim();\n\n/**\n * Converts the provided string that may contain a division operation to a number.\n *\n * @param {string} value - the provided string value\n *\n * @return {number} the parsed string value\n */\nconst parseDivisionValue = value => {\n  return parseFloat(value.split('/').reduce((prev, current) => prev / current));\n};\n\nconst parseDuration = str => {\n  const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n  const SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n  const SECONDS_IN_DAY = 24 * 60 * 60;\n  const SECONDS_IN_HOUR = 60 * 60;\n  const SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n  const durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n  const match = durationRegex.exec(str);\n\n  if (!match) {\n    return 0;\n  }\n\n  const [year, month, day, hour, minute, second] = match.slice(1);\n  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n};\nconst parseDate = str => {\n  // Date format without timezone according to ISO 8601\n  // YYY-MM-DDThh:mm:ss.ssssss\n  const dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n  // expressed by ending with 'Z'\n\n  if (dateRegex.test(str)) {\n    str += 'Z';\n  }\n\n  return Date.parse(str);\n};\n\nconst parsers = {\n  /**\n   * Specifies the duration of the entire Media Presentation. Format is a duration string\n   * as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  mediaPresentationDuration(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the Segment availability start time for all Segments referred to in this\n   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n   * time. Format is a date string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The date as seconds from unix epoch\n   */\n  availabilityStartTime(value) {\n    return parseDate(value) / 1000;\n  },\n\n  /**\n   * Specifies the smallest period between potential changes to the MPD. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  minimumUpdatePeriod(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the suggested presentation delay. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  suggestedPresentationDelay(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * specifices the type of mpd. Can be either \"static\" or \"dynamic\"\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   *\n   * @return {string}\n   *         The type as a string\n   */\n  type(value) {\n    return value;\n  },\n\n  /**\n   * Specifies the duration of the smallest time shifting buffer for any Representation\n   * in the MPD. Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  timeShiftBufferDepth(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n   * Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  start(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the width of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed width\n   */\n  width(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the height of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed height\n   */\n  height(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the bitrate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed bandwidth\n   */\n  bandwidth(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the frame rate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed frame rate\n   */\n  frameRate(value) {\n    return parseDivisionValue(value);\n  },\n\n  /**\n   * Specifies the number of the first Media Segment in this Representation in the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  startNumber(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the timescale in units per seconds\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed timescale\n   */\n  timescale(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the presentationTimeOffset.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTimeOffset\n   */\n  presentationTimeOffset(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the constant approximate Segment duration\n   * NOTE: The <Period> element also contains an @duration attribute. This duration\n   *       specifies the duration of the Period. This attribute is currently not\n   *       supported by the rest of the parser, however we still check for it to prevent\n   *       errors.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  duration(value) {\n    const parsedValue = parseInt(value, 10);\n\n    if (isNaN(parsedValue)) {\n      return parseDuration(value);\n    }\n\n    return parsedValue;\n  },\n\n  /**\n   * Specifies the Segment duration, in units of the value of the @timescale.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  d(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the MPD start time, in @timescale units, the first Segment in the series\n   * starts relative to the beginning of the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed time\n   */\n  t(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the repeat count of the number of following contiguous Segments with the\n   * same duration expressed by the value of @d\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  r(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Default parser for all other attributes. Acts as a no-op and just returns the value\n   * as a string\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {string}\n   *         Unparsed value\n   */\n  DEFAULT(value) {\n    return value;\n  }\n\n};\n/**\n * Gets all the attributes and values of the provided node, parses attributes with known\n * types, and returns an object with attribute names mapped to values.\n *\n * @param {Node} el\n *        The node to parse attributes from\n * @return {Object}\n *         Object with all attributes of el parsed\n */\n\nconst parseAttributes = el => {\n  if (!(el && el.attributes)) {\n    return {};\n  }\n\n  return from(el.attributes).reduce((a, e) => {\n    const parseFn = parsers[e.name] || parsers.DEFAULT;\n    a[e.name] = parseFn(e.value);\n    return a;\n  }, {});\n};\n\nconst keySystemsMap = {\n  'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n  'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n  'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'\n};\n/**\n * Builds a list of urls that is the product of the reference urls and BaseURL values\n *\n * @param {string[]} referenceUrls\n *        List of reference urls to resolve to\n * @param {Node[]} baseUrlElements\n *        List of BaseURL nodes from the mpd\n * @return {string[]}\n *         List of resolved urls\n */\n\nconst buildBaseUrls = (referenceUrls, baseUrlElements) => {\n  if (!baseUrlElements.length) {\n    return referenceUrls;\n  }\n\n  return flatten(referenceUrls.map(function (reference) {\n    return baseUrlElements.map(function (baseUrlElement) {\n      return resolveUrl(reference, getContent(baseUrlElement));\n    });\n  }));\n};\n/**\n * Contains all Segment information for its containing AdaptationSet\n *\n * @typedef {Object} SegmentInformation\n * @property {Object|undefined} template\n *           Contains the attributes for the SegmentTemplate node\n * @property {Object[]|undefined} segmentTimeline\n *           Contains a list of atrributes for each S node within the SegmentTimeline node\n * @property {Object|undefined} list\n *           Contains the attributes for the SegmentList node\n * @property {Object|undefined} base\n *           Contains the attributes for the SegmentBase node\n */\n\n/**\n * Returns all available Segment information contained within the AdaptationSet node\n *\n * @param {Node} adaptationSet\n *        The AdaptationSet node to get Segment information from\n * @return {SegmentInformation}\n *         The Segment information contained within the provided AdaptationSet\n */\n\nconst getSegmentInformation = adaptationSet => {\n  const segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n  const segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n  const segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(s => merge({\n    tag: 'SegmentURL'\n  }, parseAttributes(s)));\n  const segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n  const segmentTimelineParentNode = segmentList || segmentTemplate;\n  const segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n  const segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n  const segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n  // @initialization and an <Initialization> node.  @initialization can be templated,\n  // while the node can have a url and range specified.  If the <SegmentTemplate> has\n  // both @initialization and an <Initialization> subelement we opt to override with\n  // the node, as this interaction is not defined in the spec.\n\n  const template = segmentTemplate && parseAttributes(segmentTemplate);\n\n  if (template && segmentInitialization) {\n    template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n  } else if (template && template.initialization) {\n    // If it is @initialization we convert it to an object since this is the format that\n    // later functions will rely on for the initialization segment.  This is only valid\n    // for <SegmentTemplate>\n    template.initialization = {\n      sourceURL: template.initialization\n    };\n  }\n\n  const segmentInfo = {\n    template,\n    segmentTimeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(s => parseAttributes(s)),\n    list: segmentList && merge(parseAttributes(segmentList), {\n      segmentUrls,\n      initialization: parseAttributes(segmentInitialization)\n    }),\n    base: segmentBase && merge(parseAttributes(segmentBase), {\n      initialization: parseAttributes(segmentInitialization)\n    })\n  };\n  Object.keys(segmentInfo).forEach(key => {\n    if (!segmentInfo[key]) {\n      delete segmentInfo[key];\n    }\n  });\n  return segmentInfo;\n};\n/**\n * Contains Segment information and attributes needed to construct a Playlist object\n * from a Representation\n *\n * @typedef {Object} RepresentationInformation\n * @property {SegmentInformation} segmentInfo\n *           Segment information for this Representation\n * @property {Object} attributes\n *           Inherited attributes for this Representation\n */\n\n/**\n * Maps a Representation node to an object containing Segment information and attributes\n *\n * @name inheritBaseUrlsCallback\n * @function\n * @param {Node} representation\n *        Representation node from the mpd\n * @return {RepresentationInformation}\n *         Representation information needed to construct a Playlist object\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Representation nodes to\n * Segment information and attributes using inherited BaseURL nodes.\n *\n * @param {Object} adaptationSetAttributes\n *        Contains attributes inherited by the AdaptationSet\n * @param {string[]} adaptationSetBaseUrls\n *        Contains list of resolved base urls inherited by the AdaptationSet\n * @param {SegmentInformation} adaptationSetSegmentInfo\n *        Contains Segment information for the AdaptationSet\n * @return {inheritBaseUrlsCallback}\n *         Callback map function\n */\n\nconst inheritBaseUrls = (adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) => representation => {\n  const repBaseUrlElements = findChildren(representation, 'BaseURL');\n  const repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n  const attributes = merge(adaptationSetAttributes, parseAttributes(representation));\n  const representationSegmentInfo = getSegmentInformation(representation);\n  return repBaseUrls.map(baseUrl => {\n    return {\n      segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\n      attributes: merge(attributes, {\n        baseUrl\n      })\n    };\n  });\n};\n/**\n * Tranforms a series of content protection nodes to\n * an object containing pssh data by key system\n *\n * @param {Node[]} contentProtectionNodes\n *        Content protection nodes\n * @return {Object}\n *        Object containing pssh data by key system\n */\n\nconst generateKeySystemInformation = contentProtectionNodes => {\n  return contentProtectionNodes.reduce((acc, node) => {\n    const attributes = parseAttributes(node); // Although it could be argued that according to the UUID RFC spec the UUID string (a-f chars) should be generated\n    // as a lowercase string it also mentions it should be treated as case-insensitive on input. Since the key system\n    // UUIDs in the keySystemsMap are hardcoded as lowercase in the codebase there isn't any reason not to do\n    // .toLowerCase() on the input UUID string from the manifest (at least I could not think of one).\n\n    if (attributes.schemeIdUri) {\n      attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();\n    }\n\n    const keySystem = keySystemsMap[attributes.schemeIdUri];\n\n    if (keySystem) {\n      acc[keySystem] = {\n        attributes\n      };\n      const psshNode = findChildren(node, 'cenc:pssh')[0];\n\n      if (psshNode) {\n        const pssh = getContent(psshNode);\n        acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);\n      }\n    }\n\n    return acc;\n  }, {});\n}; // defined in ANSI_SCTE 214-1 2016\n\n\nconst parseCaptionServiceMetadata = service => {\n  // 608 captions\n  if (service.schemeIdUri === 'urn:scte:dash:cc:cea-608:2015') {\n    const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(value => {\n      let channel;\n      let language; // default language to value\n\n      language = value;\n\n      if (/^CC\\d=/.test(value)) {\n        [channel, language] = value.split('=');\n      } else if (/^CC\\d$/.test(value)) {\n        channel = value;\n      }\n\n      return {\n        channel,\n        language\n      };\n    });\n  } else if (service.schemeIdUri === 'urn:scte:dash:cc:cea-708:2015') {\n    const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(value => {\n      const flags = {\n        // service or channel number 1-63\n        'channel': undefined,\n        // language is a 3ALPHA per ISO 639.2/B\n        // field is required\n        'language': undefined,\n        // BIT 1/0 or ?\n        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown\n        'aspectRatio': 1,\n        // BIT 1/0\n        // easy reader flag indicated the text is tailed to the needs of beginning readers\n        // default 0, or off\n        'easyReader': 0,\n        // BIT 1/0\n        // If 3d metadata is present (CEA-708.1) then 1\n        // default 0\n        '3D': 0\n      };\n\n      if (/=/.test(value)) {\n        const [channel, opts = ''] = value.split('=');\n        flags.channel = channel;\n        flags.language = value;\n        opts.split(',').forEach(opt => {\n          const [name, val] = opt.split(':');\n\n          if (name === 'lang') {\n            flags.language = val; // er for easyReadery\n          } else if (name === 'er') {\n            flags.easyReader = Number(val); // war for wide aspect ratio\n          } else if (name === 'war') {\n            flags.aspectRatio = Number(val);\n          } else if (name === '3D') {\n            flags['3D'] = Number(val);\n          }\n        });\n      } else {\n        flags.language = value;\n      }\n\n      if (flags.channel) {\n        flags.channel = 'SERVICE' + flags.channel;\n      }\n\n      return flags;\n    });\n  }\n};\n/**\n * Maps an AdaptationSet node to a list of Representation information objects\n *\n * @name toRepresentationsCallback\n * @function\n * @param {Node} adaptationSet\n *        AdaptationSet node from the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n * Representation information objects\n *\n * @param {Object} periodAttributes\n *        Contains attributes inherited by the Period\n * @param {string[]} periodBaseUrls\n *        Contains list of resolved base urls inherited by the Period\n * @param {string[]} periodSegmentInfo\n *        Contains Segment Information at the period level\n * @return {toRepresentationsCallback}\n *         Callback map function\n */\n\nconst toRepresentations = (periodAttributes, periodBaseUrls, periodSegmentInfo) => adaptationSet => {\n  const adaptationSetAttributes = parseAttributes(adaptationSet);\n  const adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n  const role = findChildren(adaptationSet, 'Role')[0];\n  const roleAttributes = {\n    role: parseAttributes(role)\n  };\n  let attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\n  const accessibility = findChildren(adaptationSet, 'Accessibility')[0];\n  const captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));\n\n  if (captionServices) {\n    attrs = merge(attrs, {\n      captionServices\n    });\n  }\n\n  const label = findChildren(adaptationSet, 'Label')[0];\n\n  if (label && label.childNodes.length) {\n    const labelVal = label.childNodes[0].nodeValue.trim();\n    attrs = merge(attrs, {\n      label: labelVal\n    });\n  }\n\n  const contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n\n  if (Object.keys(contentProtection).length) {\n    attrs = merge(attrs, {\n      contentProtection\n    });\n  }\n\n  const segmentInfo = getSegmentInformation(adaptationSet);\n  const representations = findChildren(adaptationSet, 'Representation');\n  const adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\n  return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n};\n/**\n * Contains all period information for mapping nodes onto adaptation sets.\n *\n * @typedef {Object} PeriodInformation\n * @property {Node} period.node\n *           Period node from the mpd\n * @property {Object} period.attributes\n *           Parsed period attributes from node plus any added\n */\n\n/**\n * Maps a PeriodInformation object to a list of Representation information objects for all\n * AdaptationSet nodes contained within the Period.\n *\n * @name toAdaptationSetsCallback\n * @function\n * @param {PeriodInformation} period\n *        Period object containing necessary period information\n * @param {number} periodStart\n *        Start time of the Period within the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n * Representation information objects\n *\n * @param {Object} mpdAttributes\n *        Contains attributes inherited by the mpd\n * @param {string[]} mpdBaseUrls\n *        Contains list of resolved base urls inherited by the mpd\n * @return {toAdaptationSetsCallback}\n *         Callback map function\n */\n\nconst toAdaptationSets = (mpdAttributes, mpdBaseUrls) => (period, index) => {\n  const periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, 'BaseURL'));\n  const periodAttributes = merge(mpdAttributes, {\n    periodStart: period.attributes.start\n  });\n\n  if (typeof period.attributes.duration === 'number') {\n    periodAttributes.periodDuration = period.attributes.duration;\n  }\n\n  const adaptationSets = findChildren(period.node, 'AdaptationSet');\n  const periodSegmentInfo = getSegmentInformation(period.node);\n  return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n};\n/**\n * Gets Period@start property for a given period.\n *\n * @param {Object} options\n *        Options object\n * @param {Object} options.attributes\n *        Period attributes\n * @param {Object} [options.priorPeriodAttributes]\n *        Prior period attributes (if prior period is available)\n * @param {string} options.mpdType\n *        The MPD@type these periods came from\n * @return {number|null}\n *         The period start, or null if it's an early available period or error\n */\n\nconst getPeriodStart = ({\n  attributes,\n  priorPeriodAttributes,\n  mpdType\n}) => {\n  // Summary of period start time calculation from DASH spec section 5.3.2.1\n  //\n  // A period's start is the first period's start + time elapsed after playing all\n  // prior periods to this one. Periods continue one after the other in time (without\n  // gaps) until the end of the presentation.\n  //\n  // The value of Period@start should be:\n  // 1. if Period@start is present: value of Period@start\n  // 2. if previous period exists and it has @duration: previous Period@start +\n  //    previous Period@duration\n  // 3. if this is first period and MPD@type is 'static': 0\n  // 4. in all other cases, consider the period an \"early available period\" (note: not\n  //    currently supported)\n  // (1)\n  if (typeof attributes.start === 'number') {\n    return attributes.start;\n  } // (2)\n\n\n  if (priorPeriodAttributes && typeof priorPeriodAttributes.start === 'number' && typeof priorPeriodAttributes.duration === 'number') {\n    return priorPeriodAttributes.start + priorPeriodAttributes.duration;\n  } // (3)\n\n\n  if (!priorPeriodAttributes && mpdType === 'static') {\n    return 0;\n  } // (4)\n  // There is currently no logic for calculating the Period@start value if there is\n  // no Period@start or prior Period@start and Period@duration available. This is not made\n  // explicit by the DASH interop guidelines or the DASH spec, however, since there's\n  // nothing about any other resolution strategies, it's implied. Thus, this case should\n  // be considered an early available period, or error, and null should suffice for both\n  // of those cases.\n\n\n  return null;\n};\n/**\n * Traverses the mpd xml tree to generate a list of Representation information objects\n * that have inherited attributes from parent nodes\n *\n * @param {Node} mpd\n *        The root node of the mpd\n * @param {Object} options\n *        Available options for inheritAttributes\n * @param {string} options.manifestUri\n *        The uri source of the mpd\n * @param {number} options.NOW\n *        Current time per DASH IOP.  Default is current time in ms since epoch\n * @param {number} options.clientOffset\n *        Client time difference from NOW (in milliseconds)\n * @return {RepresentationInformation[]}\n *         List of objects containing Representation information\n */\n\nconst inheritAttributes = (mpd, options = {}) => {\n  const {\n    manifestUri = '',\n    NOW = Date.now(),\n    clientOffset = 0\n  } = options;\n  const periodNodes = findChildren(mpd, 'Period');\n\n  if (!periodNodes.length) {\n    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n  }\n\n  const locations = findChildren(mpd, 'Location');\n  const mpdAttributes = parseAttributes(mpd);\n  const mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, 'BaseURL')); // See DASH spec section 5.3.1.2, Semantics of MPD element. Default type to 'static'.\n\n  mpdAttributes.type = mpdAttributes.type || 'static';\n  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n  mpdAttributes.NOW = NOW;\n  mpdAttributes.clientOffset = clientOffset;\n\n  if (locations.length) {\n    mpdAttributes.locations = locations.map(getContent);\n  }\n\n  const periods = []; // Since toAdaptationSets acts on individual periods right now, the simplest approach to\n  // adding properties that require looking at prior periods is to parse attributes and add\n  // missing ones before toAdaptationSets is called. If more such properties are added, it\n  // may be better to refactor toAdaptationSets.\n\n  periodNodes.forEach((node, index) => {\n    const attributes = parseAttributes(node); // Use the last modified prior period, as it may contain added information necessary\n    // for this period.\n\n    const priorPeriod = periods[index - 1];\n    attributes.start = getPeriodStart({\n      attributes,\n      priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,\n      mpdType: mpdAttributes.type\n    });\n    periods.push({\n      node,\n      attributes\n    });\n  });\n  return {\n    locations: mpdAttributes.locations,\n    representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)))\n  };\n};\n\nconst stringToMpdXml = manifestString => {\n  if (manifestString === '') {\n    throw new Error(errors.DASH_EMPTY_MANIFEST);\n  }\n\n  const parser = new DOMParser();\n  let xml;\n  let mpd;\n\n  try {\n    xml = parser.parseFromString(manifestString, 'application/xml');\n    mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n  } catch (e) {// ie 11 throwsw on invalid xml\n  }\n\n  if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n    throw new Error(errors.DASH_INVALID_XML);\n  }\n\n  return mpd;\n};\n\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} mpd\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\nconst parseUTCTimingScheme = mpd => {\n  const UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n\n  if (!UTCTimingNode) {\n    return null;\n  }\n\n  const attributes = parseAttributes(UTCTimingNode);\n\n  switch (attributes.schemeIdUri) {\n    case 'urn:mpeg:dash:utc:http-head:2014':\n    case 'urn:mpeg:dash:utc:http-head:2012':\n      attributes.method = 'HEAD';\n      break;\n\n    case 'urn:mpeg:dash:utc:http-xsdate:2014':\n    case 'urn:mpeg:dash:utc:http-iso:2014':\n    case 'urn:mpeg:dash:utc:http-xsdate:2012':\n    case 'urn:mpeg:dash:utc:http-iso:2012':\n      attributes.method = 'GET';\n      break;\n\n    case 'urn:mpeg:dash:utc:direct:2014':\n    case 'urn:mpeg:dash:utc:direct:2012':\n      attributes.method = 'DIRECT';\n      attributes.value = Date.parse(attributes.value);\n      break;\n\n    case 'urn:mpeg:dash:utc:http-ntp:2014':\n    case 'urn:mpeg:dash:utc:ntp:2014':\n    case 'urn:mpeg:dash:utc:sntp:2014':\n    default:\n      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n  }\n\n  return attributes;\n};\n\nconst VERSION = version;\n/*\n * Given a DASH manifest string and options, parses the DASH manifest into an object in the\n * form outputed by m3u8-parser and accepted by videojs/http-streaming.\n *\n * For live DASH manifests, if `previousManifest` is provided in options, then the newly\n * parsed DASH manifest will have its media sequence and discontinuity sequence values\n * updated to reflect its position relative to the prior manifest.\n *\n * @param {string} manifestString - the DASH manifest as a string\n * @param {options} [options] - any options\n *\n * @return {Object} the manifest object\n */\n\nconst parse = (manifestString, options = {}) => {\n  const parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);\n  const playlists = toPlaylists(parsedManifestInfo.representationInfo);\n  return toM3u8({\n    dashPlaylists: playlists,\n    locations: parsedManifestInfo.locations,\n    sidxMapping: options.sidxMapping,\n    previousManifest: options.previousManifest\n  });\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} manifestString\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\n\nconst parseUTCTiming = manifestString => parseUTCTimingScheme(stringToMpdXml(manifestString));\n\nexport { VERSION, addSidxSegmentsToPlaylist$1 as addSidxSegmentsToPlaylist, generateSidxKey, inheritAttributes, parse, parseUTCTiming, stringToMpdXml, toM3u8, toPlaylists };\n"],"mappings":"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aAAa,CAACrH,KAAK,CAAC;EAC7B,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACElG,IAAIA,CAACkG,KAAK,EAAE;IACV,OAAOA,KAAK;EACd,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACErH,oBAAoBA,CAACqH,KAAK,EAAE;IAC1B,OAAOqH,aAAa,CAACrH,KAAK,CAAC;EAC7B,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEnL,KAAKA,CAACmL,KAAK,EAAE;IACX,OAAOqH,aAAa,CAACrH,KAAK,CAAC;EAC7B,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEqB,KAAKA,CAACrB,KAAK,EAAE;IACX,OAAO7I,QAAQ,CAAC6I,KAAK,EAAE,EAAE,CAAC;EAC5B,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEsB,MAAMA,CAACtB,KAAK,EAAE;IACZ,OAAO7I,QAAQ,CAAC6I,KAAK,EAAE,EAAE,CAAC;EAC5B,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEb,SAASA,CAACa,KAAK,EAAE;IACf,OAAO7I,QAAQ,CAAC6I,KAAK,EAAE,EAAE,CAAC;EAC5B,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEuB,SAASA,CAACvB,KAAK,EAAE;IACf,OAAOiH,kBAAkB,CAACjH,KAAK,CAAC;EAClC,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEtG,WAAWA,CAACsG,KAAK,EAAE;IACjB,OAAO7I,QAAQ,CAAC6I,KAAK,EAAE,EAAE,CAAC;EAC5B,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE/H,SAASA,CAAC+H,KAAK,EAAE;IACf,OAAO7I,QAAQ,CAAC6I,KAAK,EAAE,EAAE,CAAC;EAC5B,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEuF,sBAAsBA,CAACvF,KAAK,EAAE;IAC5B,OAAO7I,QAAQ,CAAC6I,KAAK,EAAE,EAAE,CAAC;EAC5B,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEhI,QAAQA,CAACgI,KAAK,EAAE;IACd,MAAM4I,WAAW,GAAGzR,QAAQ,CAAC6I,KAAK,EAAE,EAAE,CAAC;IAEvC,IAAIpI,KAAK,CAACgR,WAAW,CAAC,EAAE;MACtB,OAAOvB,aAAa,CAACrH,KAAK,CAAC;IAC7B;IAEA,OAAO4I,WAAW;EACpB,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE5E,CAACA,CAAChE,KAAK,EAAE;IACP,OAAO7I,QAAQ,CAAC6I,KAAK,EAAE,EAAE,CAAC;EAC5B,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEmE,CAACA,CAACnE,KAAK,EAAE;IACP,OAAO7I,QAAQ,CAAC6I,KAAK,EAAE,EAAE,CAAC;EAC5B,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE/E,CAACA,CAAC+E,KAAK,EAAE;IACP,OAAO7I,QAAQ,CAAC6I,KAAK,EAAE,EAAE,CAAC;EAC5B,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE6I,OAAOA,CAAC7I,KAAK,EAAE;IACb,OAAOA,KAAK;EACd;AAEF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM8I,eAAe,GAAGhT,EAAE,IAAI;EAC5B,IAAI,EAAEA,EAAE,IAAIA,EAAE,CAACiC,UAAU,CAAC,EAAE;IAC1B,OAAO,CAAC,CAAC;EACX;EAEA,OAAO1C,IAAI,CAACS,EAAE,CAACiC,UAAU,CAAC,CAAChE,MAAM,CAAC,CAAC0B,CAAC,EAAEC,CAAC,KAAK;IAC1C,MAAMqT,OAAO,GAAGL,OAAO,CAAChT,CAAC,CAAC2G,IAAI,CAAC,IAAIqM,OAAO,CAACG,OAAO;IAClDpT,CAAC,CAACC,CAAC,CAAC2G,IAAI,CAAC,GAAG0M,OAAO,CAACrT,CAAC,CAACsK,KAAK,CAAC;IAC5B,OAAOvK,CAAC;EACV,CAAC,EAAE,CAAC,CAAC,CAAC;AACR,CAAC;AAED,MAAMuT,aAAa,GAAG;EACpB,+CAA+C,EAAE,iBAAiB;EAClE,+CAA+C,EAAE,oBAAoB;EACrE,+CAA+C,EAAE,yBAAyB;EAC1E,+CAA+C,EAAE;AACnD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,aAAa,GAAGA,CAACC,aAAa,EAAEC,eAAe,KAAK;EACxD,IAAI,CAACA,eAAe,CAACxV,MAAM,EAAE;IAC3B,OAAOuV,aAAa;EACtB;EAEA,OAAOjU,OAAO,CAACiU,aAAa,CAACxU,GAAG,CAAC,UAAU6G,SAAS,EAAE;IACpD,OAAO4N,eAAe,CAACzU,GAAG,CAAC,UAAU0U,cAAc,EAAE;MACnD,OAAOpW,UAAU,CAACuI,SAAS,EAAEuL,UAAU,CAACsC,cAAc,CAAC,CAAC;IAC1D,CAAC,CAAC;EACJ,CAAC,CAAC,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,qBAAqB,GAAGC,aAAa,IAAI;EAC7C,MAAMC,eAAe,GAAG9C,YAAY,CAAC6C,aAAa,EAAE,iBAAiB,CAAC,CAAC,CAAC,CAAC;EACzE,MAAME,WAAW,GAAG/C,YAAY,CAAC6C,aAAa,EAAE,aAAa,CAAC,CAAC,CAAC,CAAC;EACjE,MAAM1D,WAAW,GAAG4D,WAAW,IAAI/C,YAAY,CAAC+C,WAAW,EAAE,YAAY,CAAC,CAAC9U,GAAG,CAAC+U,CAAC,IAAIjW,KAAK,CAAC;IACxFkW,GAAG,EAAE;EACP,CAAC,EAAEZ,eAAe,CAACW,CAAC,CAAC,CAAC,CAAC;EACvB,MAAME,WAAW,GAAGlD,YAAY,CAAC6C,aAAa,EAAE,aAAa,CAAC,CAAC,CAAC,CAAC;EACjE,MAAMM,yBAAyB,GAAGJ,WAAW,IAAID,eAAe;EAChE,MAAM3F,eAAe,GAAGgG,yBAAyB,IAAInD,YAAY,CAACmD,yBAAyB,EAAE,iBAAiB,CAAC,CAAC,CAAC,CAAC;EAClH,MAAMC,+BAA+B,GAAGL,WAAW,IAAIG,WAAW,IAAIJ,eAAe;EACrF,MAAMO,qBAAqB,GAAGD,+BAA+B,IAAIpD,YAAY,CAACoD,+BAA+B,EAAE,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACrI;EACA;EACA;EACA;;EAEA,MAAMzD,QAAQ,GAAGmD,eAAe,IAAIT,eAAe,CAACS,eAAe,CAAC;EAEpE,IAAInD,QAAQ,IAAI0D,qBAAqB,EAAE;IACrC1D,QAAQ,CAACjM,cAAc,GAAG2P,qBAAqB,IAAIhB,eAAe,CAACgB,qBAAqB,CAAC;EAC3F,CAAC,MAAM,IAAI1D,QAAQ,IAAIA,QAAQ,CAACjM,cAAc,EAAE;IAC9C;IACA;IACA;IACAiM,QAAQ,CAACjM,cAAc,GAAG;MACxBI,SAAS,EAAE6L,QAAQ,CAACjM;IACtB,CAAC;EACH;EAEA,MAAM8L,WAAW,GAAG;IAClBG,QAAQ;IACRxC,eAAe,EAAEA,eAAe,IAAI6C,YAAY,CAAC7C,eAAe,EAAE,GAAG,CAAC,CAAClP,GAAG,CAAC+U,CAAC,IAAIX,eAAe,CAACW,CAAC,CAAC,CAAC;IACnGnU,IAAI,EAAEkU,WAAW,IAAIhW,KAAK,CAACsV,eAAe,CAACU,WAAW,CAAC,EAAE;MACvD5D,WAAW;MACXzL,cAAc,EAAE2O,eAAe,CAACgB,qBAAqB;IACvD,CAAC,CAAC;IACFzD,IAAI,EAAEsD,WAAW,IAAInW,KAAK,CAACsV,eAAe,CAACa,WAAW,CAAC,EAAE;MACvDxP,cAAc,EAAE2O,eAAe,CAACgB,qBAAqB;IACvD,CAAC;EACH,CAAC;EACD5V,MAAM,CAACC,IAAI,CAAC8R,WAAW,CAAC,CAAC7R,OAAO,CAACC,GAAG,IAAI;IACtC,IAAI,CAAC4R,WAAW,CAAC5R,GAAG,CAAC,EAAE;MACrB,OAAO4R,WAAW,CAAC5R,GAAG,CAAC;IACzB;EACF,CAAC,CAAC;EACF,OAAO4R,WAAW;AACpB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM8D,eAAe,GAAGA,CAACC,uBAAuB,EAAEC,qBAAqB,EAAEC,wBAAwB,KAAKC,cAAc,IAAI;EACtH,MAAMC,kBAAkB,GAAG3D,YAAY,CAAC0D,cAAc,EAAE,SAAS,CAAC;EAClE,MAAME,WAAW,GAAGpB,aAAa,CAACgB,qBAAqB,EAAEG,kBAAkB,CAAC;EAC5E,MAAMrS,UAAU,GAAGvE,KAAK,CAACwW,uBAAuB,EAAElB,eAAe,CAACqB,cAAc,CAAC,CAAC;EAClF,MAAMG,yBAAyB,GAAGjB,qBAAqB,CAACc,cAAc,CAAC;EACvE,OAAOE,WAAW,CAAC3V,GAAG,CAAC+B,OAAO,IAAI;IAChC,OAAO;MACLwP,WAAW,EAAEzS,KAAK,CAAC0W,wBAAwB,EAAEI,yBAAyB,CAAC;MACvEvS,UAAU,EAAEvE,KAAK,CAACuE,UAAU,EAAE;QAC5BtB;MACF,CAAC;IACH,CAAC;EACH,CAAC,CAAC;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM8T,4BAA4B,GAAGC,sBAAsB,IAAI;EAC7D,OAAOA,sBAAsB,CAACzW,MAAM,CAAC,CAAC8B,GAAG,EAAE4U,IAAI,KAAK;IAClD,MAAM1S,UAAU,GAAG+Q,eAAe,CAAC2B,IAAI,CAAC,CAAC,CAAC;IAC1C;IACA;IACA;;IAEA,IAAI1S,UAAU,CAAC2S,WAAW,EAAE;MAC1B3S,UAAU,CAAC2S,WAAW,GAAG3S,UAAU,CAAC2S,WAAW,CAACC,WAAW,EAAE;IAC/D;IAEA,MAAMC,SAAS,GAAG5B,aAAa,CAACjR,UAAU,CAAC2S,WAAW,CAAC;IAEvD,IAAIE,SAAS,EAAE;MACb/U,GAAG,CAAC+U,SAAS,CAAC,GAAG;QACf7S;MACF,CAAC;MACD,MAAM8S,QAAQ,GAAGpE,YAAY,CAACgE,IAAI,EAAE,WAAW,CAAC,CAAC,CAAC,CAAC;MAEnD,IAAII,QAAQ,EAAE;QACZ,MAAMC,IAAI,GAAGhE,UAAU,CAAC+D,QAAQ,CAAC;QACjChV,GAAG,CAAC+U,SAAS,CAAC,CAACE,IAAI,GAAGA,IAAI,IAAI3X,qBAAqB,CAAC2X,IAAI,CAAC;MAC3D;IACF;IAEA,OAAOjV,GAAG;EACZ,CAAC,EAAE,CAAC,CAAC,CAAC;AACR,CAAC,CAAC,CAAC;;AAGH,MAAMkV,2BAA2B,GAAGnK,OAAO,IAAI;EAC7C;EACA,IAAIA,OAAO,CAAC8J,WAAW,KAAK,+BAA+B,EAAE;IAC3D,MAAMlW,MAAM,GAAG,OAAOoM,OAAO,CAACZ,KAAK,KAAK,QAAQ,GAAG,EAAE,GAAGY,OAAO,CAACZ,KAAK,CAAChJ,KAAK,CAAC,GAAG,CAAC;IAChF,OAAOxC,MAAM,CAACE,GAAG,CAACsL,KAAK,IAAI;MACzB,IAAIa,OAAO;MACX,IAAIZ,QAAQ,CAAC,CAAC;;MAEdA,QAAQ,GAAGD,KAAK;MAEhB,IAAI,QAAQ,CAACuI,IAAI,CAACvI,KAAK,CAAC,EAAE;QACxB,CAACa,OAAO,EAAEZ,QAAQ,CAAC,GAAGD,KAAK,CAAChJ,KAAK,CAAC,GAAG,CAAC;MACxC,CAAC,MAAM,IAAI,QAAQ,CAACuR,IAAI,CAACvI,KAAK,CAAC,EAAE;QAC/Ba,OAAO,GAAGb,KAAK;MACjB;MAEA,OAAO;QACLa,OAAO;QACPZ;MACF,CAAC;IACH,CAAC,CAAC;EACJ,CAAC,MAAM,IAAIW,OAAO,CAAC8J,WAAW,KAAK,+BAA+B,EAAE;IAClE,MAAMlW,MAAM,GAAG,OAAOoM,OAAO,CAACZ,KAAK,KAAK,QAAQ,GAAG,EAAE,GAAGY,OAAO,CAACZ,KAAK,CAAChJ,KAAK,CAAC,GAAG,CAAC;IAChF,OAAOxC,MAAM,CAACE,GAAG,CAACsL,KAAK,IAAI;MACzB,MAAMgL,KAAK,GAAG;QACZ;QACA,SAAS,EAAElM,SAAS;QACpB;QACA;QACA,UAAU,EAAEA,SAAS;QACrB;QACA;QACA,aAAa,EAAE,CAAC;QAChB;QACA;QACA;QACA,YAAY,EAAE,CAAC;QACf;QACA;QACA;QACA,IAAI,EAAE;MACR,CAAC;MAED,IAAI,GAAG,CAACyJ,IAAI,CAACvI,KAAK,CAAC,EAAE;QACnB,MAAM,CAACa,OAAO,EAAEoK,IAAI,GAAG,EAAE,CAAC,GAAGjL,KAAK,CAAChJ,KAAK,CAAC,GAAG,CAAC;QAC7CgU,KAAK,CAACnK,OAAO,GAAGA,OAAO;QACvBmK,KAAK,CAAC/K,QAAQ,GAAGD,KAAK;QACtBiL,IAAI,CAACjU,KAAK,CAAC,GAAG,CAAC,CAAC5C,OAAO,CAAC8W,GAAG,IAAI;UAC7B,MAAM,CAAC7O,IAAI,EAAE8O,GAAG,CAAC,GAAGD,GAAG,CAAClU,KAAK,CAAC,GAAG,CAAC;UAElC,IAAIqF,IAAI,KAAK,MAAM,EAAE;YACnB2O,KAAK,CAAC/K,QAAQ,GAAGkL,GAAG,CAAC,CAAC;UACxB,CAAC,MAAM,IAAI9O,IAAI,KAAK,IAAI,EAAE;YACxB2O,KAAK,CAAC/J,UAAU,GAAG5J,MAAM,CAAC8T,GAAG,CAAC,CAAC,CAAC;UAClC,CAAC,MAAM,IAAI9O,IAAI,KAAK,KAAK,EAAE;YACzB2O,KAAK,CAAChK,WAAW,GAAG3J,MAAM,CAAC8T,GAAG,CAAC;UACjC,CAAC,MAAM,IAAI9O,IAAI,KAAK,IAAI,EAAE;YACxB2O,KAAK,CAAC,IAAI,CAAC,GAAG3T,MAAM,CAAC8T,GAAG,CAAC;UAC3B;QACF,CAAC,CAAC;MACJ,CAAC,MAAM;QACLH,KAAK,CAAC/K,QAAQ,GAAGD,KAAK;MACxB;MAEA,IAAIgL,KAAK,CAACnK,OAAO,EAAE;QACjBmK,KAAK,CAACnK,OAAO,GAAG,SAAS,GAAGmK,KAAK,CAACnK,OAAO;MAC3C;MAEA,OAAOmK,KAAK;IACd,CAAC,CAAC;EACJ;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMI,iBAAiB,GAAGA,CAACC,gBAAgB,EAAEC,cAAc,EAAEC,iBAAiB,KAAKjC,aAAa,IAAI;EAClG,MAAMU,uBAAuB,GAAGlB,eAAe,CAACQ,aAAa,CAAC;EAC9D,MAAMW,qBAAqB,GAAGhB,aAAa,CAACqC,cAAc,EAAE7E,YAAY,CAAC6C,aAAa,EAAE,SAAS,CAAC,CAAC;EACnG,MAAMvJ,IAAI,GAAG0G,YAAY,CAAC6C,aAAa,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC;EACnD,MAAMkC,cAAc,GAAG;IACrBzL,IAAI,EAAE+I,eAAe,CAAC/I,IAAI;EAC5B,CAAC;EACD,IAAI0L,KAAK,GAAGjY,KAAK,CAAC6X,gBAAgB,EAAErB,uBAAuB,EAAEwB,cAAc,CAAC;EAC5E,MAAME,aAAa,GAAGjF,YAAY,CAAC6C,aAAa,EAAE,eAAe,CAAC,CAAC,CAAC,CAAC;EACrE,MAAM7I,eAAe,GAAGsK,2BAA2B,CAACjC,eAAe,CAAC4C,aAAa,CAAC,CAAC;EAEnF,IAAIjL,eAAe,EAAE;IACnBgL,KAAK,GAAGjY,KAAK,CAACiY,KAAK,EAAE;MACnBhL;IACF,CAAC,CAAC;EACJ;EAEA,MAAM7D,KAAK,GAAG6J,YAAY,CAAC6C,aAAa,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;EAErD,IAAI1M,KAAK,IAAIA,KAAK,CAAC+J,UAAU,CAAChT,MAAM,EAAE;IACpC,MAAMgY,QAAQ,GAAG/O,KAAK,CAAC+J,UAAU,CAAC,CAAC,CAAC,CAACiF,SAAS,CAAC5E,IAAI,EAAE;IACrDyE,KAAK,GAAGjY,KAAK,CAACiY,KAAK,EAAE;MACnB7O,KAAK,EAAE+O;IACT,CAAC,CAAC;EACJ;EAEA,MAAMnN,iBAAiB,GAAG+L,4BAA4B,CAAC9D,YAAY,CAAC6C,aAAa,EAAE,mBAAmB,CAAC,CAAC;EAExG,IAAIpV,MAAM,CAACC,IAAI,CAACqK,iBAAiB,CAAC,CAAC7K,MAAM,EAAE;IACzC8X,KAAK,GAAGjY,KAAK,CAACiY,KAAK,EAAE;MACnBjN;IACF,CAAC,CAAC;EACJ;EAEA,MAAMyH,WAAW,GAAGoD,qBAAqB,CAACC,aAAa,CAAC;EACxD,MAAM9C,eAAe,GAAGC,YAAY,CAAC6C,aAAa,EAAE,gBAAgB,CAAC;EACrE,MAAMY,wBAAwB,GAAG1W,KAAK,CAAC+X,iBAAiB,EAAEtF,WAAW,CAAC;EACtE,OAAOhR,OAAO,CAACuR,eAAe,CAAC9R,GAAG,CAACqV,eAAe,CAAC0B,KAAK,EAAExB,qBAAqB,EAAEC,wBAAwB,CAAC,CAAC,CAAC;AAC9G,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM2B,gBAAgB,GAAGA,CAACC,aAAa,EAAEC,WAAW,KAAK,CAACC,MAAM,EAAEhS,KAAK,KAAK;EAC1E,MAAMsR,cAAc,GAAGrC,aAAa,CAAC8C,WAAW,EAAEtF,YAAY,CAACuF,MAAM,CAACvB,IAAI,EAAE,SAAS,CAAC,CAAC;EACvF,MAAMY,gBAAgB,GAAG7X,KAAK,CAACsY,aAAa,EAAE;IAC5CrT,WAAW,EAAEuT,MAAM,CAACjU,UAAU,CAAClD;EACjC,CAAC,CAAC;EAEF,IAAI,OAAOmX,MAAM,CAACjU,UAAU,CAACC,QAAQ,KAAK,QAAQ,EAAE;IAClDqT,gBAAgB,CAAClT,cAAc,GAAG6T,MAAM,CAACjU,UAAU,CAACC,QAAQ;EAC9D;EAEA,MAAMiU,cAAc,GAAGxF,YAAY,CAACuF,MAAM,CAACvB,IAAI,EAAE,eAAe,CAAC;EACjE,MAAMc,iBAAiB,GAAGlC,qBAAqB,CAAC2C,MAAM,CAACvB,IAAI,CAAC;EAC5D,OAAOxV,OAAO,CAACgX,cAAc,CAACvX,GAAG,CAAC0W,iBAAiB,CAACC,gBAAgB,EAAEC,cAAc,EAAEC,iBAAiB,CAAC,CAAC,CAAC;AAC5G,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMW,cAAc,GAAGC,MAAA,IAIjB;EAAA,IAJkB;IACtBpU,UAAU;IACVqU,qBAAqB;IACrBC;EACF,CAAC,GAAAF,MAAA;EACC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAI,OAAOpU,UAAU,CAAClD,KAAK,KAAK,QAAQ,EAAE;IACxC,OAAOkD,UAAU,CAAClD,KAAK;EACzB,CAAC,CAAC;;EAGF,IAAIuX,qBAAqB,IAAI,OAAOA,qBAAqB,CAACvX,KAAK,KAAK,QAAQ,IAAI,OAAOuX,qBAAqB,CAACpU,QAAQ,KAAK,QAAQ,EAAE;IAClI,OAAOoU,qBAAqB,CAACvX,KAAK,GAAGuX,qBAAqB,CAACpU,QAAQ;EACrE,CAAC,CAAC;;EAGF,IAAI,CAACoU,qBAAqB,IAAIC,OAAO,KAAK,QAAQ,EAAE;IAClD,OAAO,CAAC;EACV,CAAC,CAAC;EACF;EACA;EACA;EACA;EACA;EACA;;EAGA,OAAO,IAAI;AACb,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,iBAAiB,GAAG,SAAAA,CAACC,GAAG,EAAmB;EAAA,IAAjBC,OAAO,GAAA9Y,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAoL,SAAA,GAAApL,SAAA,MAAG,CAAC,CAAC;EAC1C,MAAM;IACJ+Y,WAAW,GAAG,EAAE;IAChBnU,GAAG,GAAGkQ,IAAI,CAAC3P,GAAG,EAAE;IAChBN,YAAY,GAAG;EACjB,CAAC,GAAGiU,OAAO;EACX,MAAME,WAAW,GAAGjG,YAAY,CAAC8F,GAAG,EAAE,QAAQ,CAAC;EAE/C,IAAI,CAACG,WAAW,CAAC/Y,MAAM,EAAE;IACvB,MAAM,IAAI0G,KAAK,CAACtE,MAAM,CAACC,wBAAwB,CAAC;EAClD;EAEA,MAAMwM,SAAS,GAAGiE,YAAY,CAAC8F,GAAG,EAAE,UAAU,CAAC;EAC/C,MAAMT,aAAa,GAAGhD,eAAe,CAACyD,GAAG,CAAC;EAC1C,MAAMR,WAAW,GAAG9C,aAAa,CAAC,CAACwD,WAAW,CAAC,EAAEhG,YAAY,CAAC8F,GAAG,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;;EAEhFT,aAAa,CAAChS,IAAI,GAAGgS,aAAa,CAAChS,IAAI,IAAI,QAAQ;EACnDgS,aAAa,CAAC5T,cAAc,GAAG4T,aAAa,CAACnD,yBAAyB,IAAI,CAAC;EAC3EmD,aAAa,CAACxT,GAAG,GAAGA,GAAG;EACvBwT,aAAa,CAACvT,YAAY,GAAGA,YAAY;EAEzC,IAAIiK,SAAS,CAAC7O,MAAM,EAAE;IACpBmY,aAAa,CAACtJ,SAAS,GAAGA,SAAS,CAAC9N,GAAG,CAACoS,UAAU,CAAC;EACrD;EAEA,MAAM6F,OAAO,GAAG,EAAE,CAAC,CAAC;EACpB;EACA;EACA;;EAEAD,WAAW,CAACtY,OAAO,CAAC,CAACqW,IAAI,EAAEzQ,KAAK,KAAK;IACnC,MAAMjC,UAAU,GAAG+Q,eAAe,CAAC2B,IAAI,CAAC,CAAC,CAAC;IAC1C;;IAEA,MAAMmC,WAAW,GAAGD,OAAO,CAAC3S,KAAK,GAAG,CAAC,CAAC;IACtCjC,UAAU,CAAClD,KAAK,GAAGqX,cAAc,CAAC;MAChCnU,UAAU;MACVqU,qBAAqB,EAAEQ,WAAW,GAAGA,WAAW,CAAC7U,UAAU,GAAG,IAAI;MAClEsU,OAAO,EAAEP,aAAa,CAAChS;IACzB,CAAC,CAAC;IACF6S,OAAO,CAAC3X,IAAI,CAAC;MACXyV,IAAI;MACJ1S;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,OAAO;IACLyK,SAAS,EAAEsJ,aAAa,CAACtJ,SAAS;IAClCqK,kBAAkB,EAAE5X,OAAO,CAAC0X,OAAO,CAACjY,GAAG,CAACmX,gBAAgB,CAACC,aAAa,EAAEC,WAAW,CAAC,CAAC;EACvF,CAAC;AACH,CAAC;AAED,MAAMe,cAAc,GAAGC,cAAc,IAAI;EACvC,IAAIA,cAAc,KAAK,EAAE,EAAE;IACzB,MAAM,IAAI1S,KAAK,CAACtE,MAAM,CAACE,mBAAmB,CAAC;EAC7C;EAEA,MAAM+W,MAAM,GAAG,IAAI5Z,SAAS,EAAE;EAC9B,IAAI6Z,GAAG;EACP,IAAIV,GAAG;EAEP,IAAI;IACFU,GAAG,GAAGD,MAAM,CAACE,eAAe,CAACH,cAAc,EAAE,iBAAiB,CAAC;IAC/DR,GAAG,GAAGU,GAAG,IAAIA,GAAG,CAACE,eAAe,CAACtG,OAAO,KAAK,KAAK,GAAGoG,GAAG,CAACE,eAAe,GAAG,IAAI;EACjF,CAAC,CAAC,OAAOzX,CAAC,EAAE,CAAC;EAAA;EAGb,IAAI,CAAC6W,GAAG,IAAIA,GAAG,IAAIA,GAAG,CAACa,oBAAoB,CAAC,aAAa,CAAC,CAACzZ,MAAM,GAAG,CAAC,EAAE;IACrE,MAAM,IAAI0G,KAAK,CAACtE,MAAM,CAACG,gBAAgB,CAAC;EAC1C;EAEA,OAAOqW,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMc,oBAAoB,GAAGd,GAAG,IAAI;EAClC,MAAMe,aAAa,GAAG7G,YAAY,CAAC8F,GAAG,EAAE,WAAW,CAAC,CAAC,CAAC,CAAC;EAEvD,IAAI,CAACe,aAAa,EAAE;IAClB,OAAO,IAAI;EACb;EAEA,MAAMvV,UAAU,GAAG+Q,eAAe,CAACwE,aAAa,CAAC;EAEjD,QAAQvV,UAAU,CAAC2S,WAAW;IAC5B,KAAK,kCAAkC;IACvC,KAAK,kCAAkC;MACrC3S,UAAU,CAACwV,MAAM,GAAG,MAAM;MAC1B;IAEF,KAAK,oCAAoC;IACzC,KAAK,iCAAiC;IACtC,KAAK,oCAAoC;IACzC,KAAK,iCAAiC;MACpCxV,UAAU,CAACwV,MAAM,GAAG,KAAK;MACzB;IAEF,KAAK,+BAA+B;IACpC,KAAK,+BAA+B;MAClCxV,UAAU,CAACwV,MAAM,GAAG,QAAQ;MAC5BxV,UAAU,CAACiI,KAAK,GAAGwI,IAAI,CAACC,KAAK,CAAC1Q,UAAU,CAACiI,KAAK,CAAC;MAC/C;IAEF,KAAK,iCAAiC;IACtC,KAAK,4BAA4B;IACjC,KAAK,6BAA6B;IAClC;MACE,MAAM,IAAI3F,KAAK,CAACtE,MAAM,CAACO,6BAA6B,CAAC;EAAC;EAG1D,OAAOyB,UAAU;AACnB,CAAC;AAED,MAAMyV,OAAO,GAAGna,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMoV,KAAK,GAAG,SAAAA,CAACsE,cAAc,EAAmB;EAAA,IAAjBP,OAAO,GAAA9Y,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAoL,SAAA,GAAApL,SAAA,MAAG,CAAC,CAAC;EACzC,MAAM+Z,kBAAkB,GAAGnB,iBAAiB,CAACQ,cAAc,CAACC,cAAc,CAAC,EAAEP,OAAO,CAAC;EACrF,MAAMpQ,SAAS,GAAGmK,WAAW,CAACkH,kBAAkB,CAACZ,kBAAkB,CAAC;EACpE,OAAOxK,MAAM,CAAC;IACZE,aAAa,EAAEnG,SAAS;IACxBoG,SAAS,EAAEiL,kBAAkB,CAACjL,SAAS;IACvC9D,WAAW,EAAE8N,OAAO,CAAC9N,WAAW;IAChC+D,gBAAgB,EAAE+J,OAAO,CAAC/J;EAC5B,CAAC,CAAC;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,MAAMiL,cAAc,GAAGX,cAAc,IAAIM,oBAAoB,CAACP,cAAc,CAACC,cAAc,CAAC,CAAC;AAE7F,SAASS,OAAO,EAAE/S,2BAA2B,IAAIgE,yBAAyB,EAAEN,eAAe,EAAEmO,iBAAiB,EAAE7D,KAAK,EAAEiF,cAAc,EAAEZ,cAAc,EAAEzK,MAAM,EAAEkE,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}